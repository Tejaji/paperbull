This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.env.local
backend/.env
backend/.env.local
backend/.upstox-token.json
backend/package.json
backend/prisma/migrations/20251108052839_init/migration.sql
backend/prisma/migrations/20251108150615_add_phone_and_otp/migration.sql
backend/prisma/migrations/20251115123013_add_phone_auth/migration.sql
backend/prisma/migrations/20251115131714_add_app_settings/migration.sql
backend/prisma/migrations/20251115134853_add_announcements/migration.sql
backend/prisma/migrations/migration_lock.toml
backend/prisma/schema.prisma
backend/src/config/constants.ts
backend/src/controllers/auth.controller.ts
backend/src/controllers/market.controller.ts
backend/src/controllers/orders.controller.ts
backend/src/controllers/positions.controller.ts
backend/src/index.ts
backend/src/routes/admin.routes.ts
backend/src/routes/auth.routes.ts
backend/src/routes/market-data.routes.ts
backend/src/routes/market.routes.ts
backend/src/routes/order.routes.ts
backend/src/routes/paper-trading.routes.ts
backend/src/routes/payment.routes.ts
backend/src/routes/position.routes.ts
backend/src/routes/public.routes.ts
backend/src/seed.ts
backend/src/services/market-data.service.ts
backend/src/services/order.service.ts
backend/src/services/pnl.service.ts
backend/src/services/quote.service.ts
backend/src/services/upstox.service.ts
backend/src/utils/helpers.ts
backend/src/websocket/ws.server.ts
backend/tsconfig.json
frontend/.gitignore
frontend/app/admin/page.tsx
frontend/app/favicon.ico
frontend/app/globals.css
frontend/app/layout.tsx
frontend/app/login/page.tsx
frontend/app/page.tsx
frontend/app/payment/page.tsx
frontend/app/trading/page.tsx
frontend/components/AnnouncementBanner.tsx
frontend/components/MarketClosedModal.tsx
frontend/components/MarketTicker.tsx
frontend/components/OptionChain.tsx
frontend/components/OrderHistory.tsx
frontend/components/OrderModal.tsx
frontend/components/Positions.tsx
frontend/components/Toast.tsx
frontend/components/ToastContainer.tsx
frontend/eslint.config.mjs
frontend/hooks/useWebSocket.ts
frontend/lib/api.ts
frontend/next.config.ts
frontend/package.json
frontend/postcss.config.mjs
frontend/public/file.svg
frontend/public/globe.svg
frontend/public/next.svg
frontend/public/vercel.svg
frontend/public/window.svg
frontend/README.md
frontend/src/api.ts
frontend/src/axios.ts
frontend/tsconfig.json
frontend/utils/marketStatus.ts
New folder/Project withou log in.xml
package.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".env.local">
# API Keys
API_KEY=72adba8b-4015-4bdc-8820-90a8b78a11dc
API_SECRET=li111hdepq

# Backend Configuration (if needed)
DATABASE_URL=your_database_connection_string
NEXT_PUBLIC_API_URL=http://localhost:3001
</file>

<file path="backend/.env">
DATABASE_URL="postgresql://postgres:admin@localhost:5432/papertrading?schema=public"
REDIS_URL="redis://localhost:6379"
JWT_SECRET="my-super-secret-key-change-this-in-production"
PORT=3001
NODE_ENV=development
MSG91_AUTH_KEY=your-msg91-auth-key
MSG91_TEMPLATE_ID=your-template-id
JWT_SECRET=your-strong-secret-key
NODE_ENV=development
</file>

<file path="backend/.env.local">
# Server Configuration
PORT=3001
NODE_ENV=development

# Upstox API Credentials
UPSTOX_API_KEY=72adba8b-4015-4bdc-8820-90a8b78a11dc
UPSTOX_API_SECRET=li111hdepq
UPSTOX_REDIRECT_URI=http://localhost:3001/auth/upstox/callback
ADMIN_KEY=your-super-secret-admin-key-12345
# This will be generated after login
UPSTOX_ACCESS_TOKEN=

# Frontend URL
NEXT_PUBLIC_API_URL=http://localhost:3001
</file>

<file path="backend/.upstox-token.json">
{
  "access_token": "eyJ0eXAiOiJKV1QiLCJrZXlfaWQiOiJza192MS4wIiwiYWxnIjoiSFMyNTYifQ.eyJzdWIiOiI0TkNYVDUiLCJqdGkiOiI2OTE4MmRmN2JiZjU2ODY3NGZlZTlkMTkiLCJpc011bHRpQ2xpZW50IjpmYWxzZSwiaXNQbHVzUGxhbiI6dHJ1ZSwiaWF0IjoxNzYzMTkyMzExLCJpc3MiOiJ1ZGFwaS1nYXRld2F5LXNlcnZpY2UiLCJleHAiOjE3NjMyNDQwMDB9.i42Lsw-TSa_C8G0bS9YsUpAgTMTY74WNE9ohzsgYV1M",
  "saved_at": "2025-11-15T07:38:29.956Z"
}
</file>

<file path="backend/package.json">
{
  "name": "paper-trading-backend",
  "version": "1.0.0",
  "description": "Paper Trading Backend with Upstox API",
  "main": "dist/index.js",
  "scripts": {
    "dev": "nodemon --exec ts-node src/index.ts",
    "build": "tsc",
    "start": "node dist/index.js",
    "clean": "rm -rf dist"
  },
  "dependencies": {
    "axios": "^1.6.0",
    "cors": "^2.8.5",
    "dotenv": "^16.3.1",
    "express": "^4.18.2"
  },
  "devDependencies": {
    "@types/cors": "^2.8.14",
    "@types/express": "^4.17.18",
    "@types/node": "^20.8.0",
    "nodemon": "^3.0.1",
    "ts-node": "^10.9.1",
    "typescript": "^5.2.2"
  }
}
</file>

<file path="backend/prisma/migrations/20251108052839_init/migration.sql">
-- CreateTable
CREATE TABLE "users" (
    "id" TEXT NOT NULL,
    "email" TEXT NOT NULL,
    "hash" TEXT NOT NULL,
    "role" TEXT NOT NULL DEFAULT 'free',
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "users_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "accounts" (
    "id" TEXT NOT NULL,
    "userId" TEXT NOT NULL,
    "nickname" TEXT NOT NULL DEFAULT 'Default',
    "baseCapital" DECIMAL(14,2) NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "accounts_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "indices" (
    "symbol" TEXT NOT NULL,
    "displayName" TEXT NOT NULL,
    "lotSize" INTEGER NOT NULL,

    CONSTRAINT "indices_pkey" PRIMARY KEY ("symbol")
);

-- CreateTable
CREATE TABLE "option_contracts" (
    "id" BIGSERIAL NOT NULL,
    "indexSymbol" TEXT NOT NULL,
    "expiryDate" DATE NOT NULL,
    "strike" DECIMAL(10,2) NOT NULL,
    "optionType" TEXT NOT NULL,
    "tradingSymbol" TEXT NOT NULL,
    "tickSize" DECIMAL(8,2) NOT NULL DEFAULT 0.05,
    "lotSize" INTEGER NOT NULL,

    CONSTRAINT "option_contracts_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "orders" (
    "id" TEXT NOT NULL,
    "accountId" TEXT NOT NULL,
    "contractId" BIGINT NOT NULL,
    "side" TEXT NOT NULL,
    "qty" INTEGER NOT NULL,
    "orderType" TEXT NOT NULL,
    "limitPrice" DECIMAL(10,2),
    "triggerPrice" DECIMAL(10,2),
    "status" TEXT NOT NULL DEFAULT 'OPEN',
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "orders_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "trades" (
    "id" BIGSERIAL NOT NULL,
    "orderId" TEXT NOT NULL,
    "contractId" BIGINT NOT NULL,
    "side" TEXT NOT NULL,
    "qty" INTEGER NOT NULL,
    "price" DECIMAL(10,2) NOT NULL,
    "tradedAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "trades_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "positions" (
    "id" BIGSERIAL NOT NULL,
    "accountId" TEXT NOT NULL,
    "contractId" BIGINT NOT NULL,
    "netLots" INTEGER NOT NULL,
    "avgPrice" DECIMAL(10,2) NOT NULL,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "positions_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "cash_ledger" (
    "id" BIGSERIAL NOT NULL,
    "accountId" TEXT NOT NULL,
    "type" TEXT NOT NULL,
    "amount" DECIMAL(12,2) NOT NULL,
    "reason" TEXT,
    "refId" TEXT,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "cash_ledger_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "users_email_key" ON "users"("email");

-- CreateIndex
CREATE UNIQUE INDEX "option_contracts_tradingSymbol_key" ON "option_contracts"("tradingSymbol");

-- CreateIndex
CREATE UNIQUE INDEX "positions_accountId_contractId_key" ON "positions"("accountId", "contractId");

-- AddForeignKey
ALTER TABLE "accounts" ADD CONSTRAINT "accounts_userId_fkey" FOREIGN KEY ("userId") REFERENCES "users"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "option_contracts" ADD CONSTRAINT "option_contracts_indexSymbol_fkey" FOREIGN KEY ("indexSymbol") REFERENCES "indices"("symbol") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "orders" ADD CONSTRAINT "orders_accountId_fkey" FOREIGN KEY ("accountId") REFERENCES "accounts"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "orders" ADD CONSTRAINT "orders_contractId_fkey" FOREIGN KEY ("contractId") REFERENCES "option_contracts"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "trades" ADD CONSTRAINT "trades_orderId_fkey" FOREIGN KEY ("orderId") REFERENCES "orders"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "trades" ADD CONSTRAINT "trades_contractId_fkey" FOREIGN KEY ("contractId") REFERENCES "option_contracts"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "positions" ADD CONSTRAINT "positions_accountId_fkey" FOREIGN KEY ("accountId") REFERENCES "accounts"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "positions" ADD CONSTRAINT "positions_contractId_fkey" FOREIGN KEY ("contractId") REFERENCES "option_contracts"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "cash_ledger" ADD CONSTRAINT "cash_ledger_accountId_fkey" FOREIGN KEY ("accountId") REFERENCES "accounts"("id") ON DELETE RESTRICT ON UPDATE CASCADE;
</file>

<file path="backend/prisma/migrations/20251108150615_add_phone_and_otp/migration.sql">
/*
  Warnings:

  - The primary key for the `accounts` table will be changed. If it partially fails, the table could be left without primary key constraint.
  - You are about to drop the column `baseCapital` on the `accounts` table. All the data in the column will be lost.
  - You are about to drop the column `nickname` on the `accounts` table. All the data in the column will be lost.
  - The `id` column on the `accounts` table would be dropped and recreated. This will lead to data loss if there is data in the column.
  - The primary key for the `indices` table will be changed. If it partially fails, the table could be left without primary key constraint.
  - The primary key for the `orders` table will be changed. If it partially fails, the table could be left without primary key constraint.
  - The `id` column on the `orders` table would be dropped and recreated. This will lead to data loss if there is data in the column.
  - You are about to drop the column `netLots` on the `positions` table. All the data in the column will be lost.
  - You are about to drop the column `tradedAt` on the `trades` table. All the data in the column will be lost.
  - The primary key for the `users` table will be changed. If it partially fails, the table could be left without primary key constraint.
  - You are about to drop the column `hash` on the `users` table. All the data in the column will be lost.
  - The `id` column on the `users` table would be dropped and recreated. This will lead to data loss if there is data in the column.
  - You are about to drop the `cash_ledger` table. If the table is not empty, all the data it contains will be lost.
  - A unique constraint covering the columns `[symbol]` on the table `indices` will be added. If there are existing duplicate values, this will fail.
  - A unique constraint covering the columns `[phone]` on the table `users` will be added. If there are existing duplicate values, this will fail.
  - A unique constraint covering the columns `[username]` on the table `users` will be added. If there are existing duplicate values, this will fail.
  - Added the required column `balance` to the `accounts` table without a default value. This is not possible if the table is not empty.
  - Added the required column `updatedAt` to the `accounts` table without a default value. This is not possible if the table is not empty.
  - Changed the type of `userId` on the `accounts` table. No cast exists, the column would be dropped and recreated, which cannot be done if there is data, since the column is required.
  - Added the required column `updatedAt` to the `indices` table without a default value. This is not possible if the table is not empty.
  - Added the required column `updatedAt` to the `option_contracts` table without a default value. This is not possible if the table is not empty.
  - Added the required column `updatedAt` to the `orders` table without a default value. This is not possible if the table is not empty.
  - Changed the type of `accountId` on the `orders` table. No cast exists, the column would be dropped and recreated, which cannot be done if there is data, since the column is required.
  - Added the required column `netQty` to the `positions` table without a default value. This is not possible if the table is not empty.
  - Changed the type of `accountId` on the `positions` table. No cast exists, the column would be dropped and recreated, which cannot be done if there is data, since the column is required.
  - Added the required column `accountId` to the `trades` table without a default value. This is not possible if the table is not empty.
  - Changed the type of `orderId` on the `trades` table. No cast exists, the column would be dropped and recreated, which cannot be done if there is data, since the column is required.
  - Added the required column `phone` to the `users` table without a default value. This is not possible if the table is not empty.
  - Added the required column `updatedAt` to the `users` table without a default value. This is not possible if the table is not empty.
  - Added the required column `username` to the `users` table without a default value. This is not possible if the table is not empty.

*/
-- DropForeignKey
ALTER TABLE "accounts" DROP CONSTRAINT "accounts_userId_fkey";

-- DropForeignKey
ALTER TABLE "cash_ledger" DROP CONSTRAINT "cash_ledger_accountId_fkey";

-- DropForeignKey
ALTER TABLE "option_contracts" DROP CONSTRAINT "option_contracts_indexSymbol_fkey";

-- DropForeignKey
ALTER TABLE "orders" DROP CONSTRAINT "orders_accountId_fkey";

-- DropForeignKey
ALTER TABLE "positions" DROP CONSTRAINT "positions_accountId_fkey";

-- DropForeignKey
ALTER TABLE "trades" DROP CONSTRAINT "trades_orderId_fkey";

-- AlterTable
ALTER TABLE "accounts" DROP CONSTRAINT "accounts_pkey",
DROP COLUMN "baseCapital",
DROP COLUMN "nickname",
ADD COLUMN     "balance" DECIMAL(20,2) NOT NULL,
ADD COLUMN     "updatedAt" TIMESTAMP(3) NOT NULL,
DROP COLUMN "id",
ADD COLUMN     "id" BIGSERIAL NOT NULL,
DROP COLUMN "userId",
ADD COLUMN     "userId" BIGINT NOT NULL,
ADD CONSTRAINT "accounts_pkey" PRIMARY KEY ("id");

-- AlterTable
ALTER TABLE "indices" DROP CONSTRAINT "indices_pkey",
ADD COLUMN     "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
ADD COLUMN     "id" BIGSERIAL NOT NULL,
ADD COLUMN     "updatedAt" TIMESTAMP(3) NOT NULL,
ADD CONSTRAINT "indices_pkey" PRIMARY KEY ("id");

-- AlterTable
ALTER TABLE "option_contracts" ADD COLUMN     "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
ADD COLUMN     "updatedAt" TIMESTAMP(3) NOT NULL,
ALTER COLUMN "expiryDate" SET DATA TYPE TIMESTAMP(3),
ALTER COLUMN "tickSize" DROP NOT NULL,
ALTER COLUMN "tickSize" DROP DEFAULT,
ALTER COLUMN "tickSize" SET DATA TYPE DECIMAL(10,2);

-- AlterTable
ALTER TABLE "orders" DROP CONSTRAINT "orders_pkey",
ADD COLUMN     "updatedAt" TIMESTAMP(3) NOT NULL,
DROP COLUMN "id",
ADD COLUMN     "id" BIGSERIAL NOT NULL,
DROP COLUMN "accountId",
ADD COLUMN     "accountId" BIGINT NOT NULL,
ALTER COLUMN "limitPrice" SET DATA TYPE DECIMAL(20,2),
ALTER COLUMN "triggerPrice" SET DATA TYPE DECIMAL(20,2),
ALTER COLUMN "status" SET DEFAULT 'PENDING',
ADD CONSTRAINT "orders_pkey" PRIMARY KEY ("id");

-- AlterTable
ALTER TABLE "positions" DROP COLUMN "netLots",
ADD COLUMN     "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
ADD COLUMN     "netQty" INTEGER NOT NULL,
ADD COLUMN     "realizedPnL" DECIMAL(20,2) NOT NULL DEFAULT 0,
DROP COLUMN "accountId",
ADD COLUMN     "accountId" BIGINT NOT NULL,
ALTER COLUMN "avgPrice" SET DATA TYPE DECIMAL(20,2);

-- AlterTable
ALTER TABLE "trades" DROP COLUMN "tradedAt",
ADD COLUMN     "accountId" BIGINT NOT NULL,
ADD COLUMN     "executedAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
ADD COLUMN     "fees" DECIMAL(20,2) NOT NULL DEFAULT 0,
DROP COLUMN "orderId",
ADD COLUMN     "orderId" BIGINT NOT NULL,
ALTER COLUMN "price" SET DATA TYPE DECIMAL(20,2);

-- AlterTable
ALTER TABLE "users" DROP CONSTRAINT "users_pkey",
DROP COLUMN "hash",
ADD COLUMN     "passwordHash" TEXT,
ADD COLUMN     "phone" TEXT NOT NULL,
ADD COLUMN     "updatedAt" TIMESTAMP(3) NOT NULL,
ADD COLUMN     "username" TEXT NOT NULL,
DROP COLUMN "id",
ADD COLUMN     "id" BIGSERIAL NOT NULL,
ADD CONSTRAINT "users_pkey" PRIMARY KEY ("id");

-- DropTable
DROP TABLE "cash_ledger";

-- CreateTable
CREATE TABLE "otps" (
    "id" BIGSERIAL NOT NULL,
    "phone" TEXT NOT NULL,
    "otp" TEXT NOT NULL,
    "expiresAt" TIMESTAMP(3) NOT NULL,
    "verified" BOOLEAN NOT NULL DEFAULT false,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "otps_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE INDEX "otps_phone_idx" ON "otps"("phone");

-- CreateIndex
CREATE UNIQUE INDEX "indices_symbol_key" ON "indices"("symbol");

-- CreateIndex
CREATE UNIQUE INDEX "positions_accountId_contractId_key" ON "positions"("accountId", "contractId");

-- CreateIndex
CREATE UNIQUE INDEX "users_phone_key" ON "users"("phone");

-- CreateIndex
CREATE UNIQUE INDEX "users_username_key" ON "users"("username");

-- AddForeignKey
ALTER TABLE "accounts" ADD CONSTRAINT "accounts_userId_fkey" FOREIGN KEY ("userId") REFERENCES "users"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "orders" ADD CONSTRAINT "orders_accountId_fkey" FOREIGN KEY ("accountId") REFERENCES "accounts"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "trades" ADD CONSTRAINT "trades_orderId_fkey" FOREIGN KEY ("orderId") REFERENCES "orders"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "trades" ADD CONSTRAINT "trades_accountId_fkey" FOREIGN KEY ("accountId") REFERENCES "accounts"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "positions" ADD CONSTRAINT "positions_accountId_fkey" FOREIGN KEY ("accountId") REFERENCES "accounts"("id") ON DELETE RESTRICT ON UPDATE CASCADE;
</file>

<file path="backend/prisma/migrations/20251115123013_add_phone_auth/migration.sql">
/*
  Warnings:

  - You are about to drop the column `updatedAt` on the `accounts` table. All the data in the column will be lost.
  - You are about to drop the column `createdAt` on the `indices` table. All the data in the column will be lost.
  - You are about to drop the column `updatedAt` on the `indices` table. All the data in the column will be lost.
  - You are about to drop the column `createdAt` on the `option_contracts` table. All the data in the column will be lost.
  - You are about to drop the column `tickSize` on the `option_contracts` table. All the data in the column will be lost.
  - You are about to drop the column `updatedAt` on the `option_contracts` table. All the data in the column will be lost.
  - You are about to drop the column `contractId` on the `orders` table. All the data in the column will be lost.
  - You are about to drop the column `limitPrice` on the `orders` table. All the data in the column will be lost.
  - You are about to drop the column `updatedAt` on the `orders` table. All the data in the column will be lost.
  - You are about to drop the column `netQty` on the `positions` table. All the data in the column will be lost.
  - You are about to drop the column `realizedPnL` on the `positions` table. All the data in the column will be lost.
  - You are about to drop the column `accountId` on the `trades` table. All the data in the column will be lost.
  - You are about to drop the column `executedAt` on the `trades` table. All the data in the column will be lost.
  - You are about to drop the column `fees` on the `trades` table. All the data in the column will be lost.
  - You are about to drop the column `side` on the `trades` table. All the data in the column will be lost.
  - Added the required column `tradingSymbol` to the `orders` table without a default value. This is not possible if the table is not empty.
  - Added the required column `qty` to the `positions` table without a default value. This is not possible if the table is not empty.

*/
-- DropForeignKey
ALTER TABLE "orders" DROP CONSTRAINT "orders_contractId_fkey";

-- DropForeignKey
ALTER TABLE "trades" DROP CONSTRAINT "trades_accountId_fkey";

-- AlterTable
ALTER TABLE "accounts" DROP COLUMN "updatedAt",
ALTER COLUMN "balance" SET DEFAULT 100000,
ALTER COLUMN "balance" SET DATA TYPE DECIMAL(65,30);

-- AlterTable
ALTER TABLE "indices" DROP COLUMN "createdAt",
DROP COLUMN "updatedAt";

-- AlterTable
ALTER TABLE "option_contracts" DROP COLUMN "createdAt",
DROP COLUMN "tickSize",
DROP COLUMN "updatedAt",
ALTER COLUMN "expiryDate" SET DATA TYPE TEXT,
ALTER COLUMN "strike" SET DATA TYPE DECIMAL(65,30);

-- AlterTable
ALTER TABLE "orders" DROP COLUMN "contractId",
DROP COLUMN "limitPrice",
DROP COLUMN "updatedAt",
ADD COLUMN     "avgPrice" DECIMAL(65,30) NOT NULL DEFAULT 0,
ADD COLUMN     "filledQty" INTEGER NOT NULL DEFAULT 0,
ADD COLUMN     "price" DECIMAL(65,30),
ADD COLUMN     "tradingSymbol" TEXT NOT NULL,
ALTER COLUMN "triggerPrice" SET DATA TYPE DECIMAL(65,30),
ALTER COLUMN "status" DROP DEFAULT;

-- AlterTable
ALTER TABLE "positions" DROP COLUMN "netQty",
DROP COLUMN "realizedPnL",
ADD COLUMN     "qty" INTEGER NOT NULL,
ALTER COLUMN "avgPrice" SET DATA TYPE DECIMAL(65,30);

-- AlterTable
ALTER TABLE "trades" DROP COLUMN "accountId",
DROP COLUMN "executedAt",
DROP COLUMN "fees",
DROP COLUMN "side",
ADD COLUMN     "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
ALTER COLUMN "price" SET DATA TYPE DECIMAL(65,30);
</file>

<file path="backend/prisma/migrations/20251115131714_add_app_settings/migration.sql">
-- CreateTable
CREATE TABLE "AppSettings" (
    "id" BIGSERIAL NOT NULL,
    "premiumPrice" INTEGER NOT NULL DEFAULT 99,
    "freeCapital" DECIMAL(65,30) NOT NULL DEFAULT 100000,
    "premiumCapital" DECIMAL(65,30) NOT NULL DEFAULT 1000000,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "AppSettings_pkey" PRIMARY KEY ("id")
);
</file>

<file path="backend/prisma/migrations/20251115134853_add_announcements/migration.sql">
-- CreateTable
CREATE TABLE "Announcement" (
    "id" BIGSERIAL NOT NULL,
    "title" TEXT NOT NULL,
    "message" TEXT NOT NULL,
    "targetRole" TEXT NOT NULL DEFAULT 'all',
    "type" TEXT NOT NULL DEFAULT 'info',
    "isActive" BOOLEAN NOT NULL DEFAULT true,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "expiresAt" TIMESTAMP(3),

    CONSTRAINT "Announcement_pkey" PRIMARY KEY ("id")
);
</file>

<file path="backend/prisma/migrations/migration_lock.toml">
# Please do not edit this file manually
# It should be added in your version-control system (e.g., Git)
provider = "postgresql"
</file>

<file path="backend/prisma/schema.prisma">
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id              BigInt    @id @default(autoincrement())
  email           String    @unique
  phone           String    @unique
  username        String    @unique
  passwordHash    String?
  role            String    @default("free") // 'free' or 'premium'
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  
  accounts        Account[]
  
  @@map("users")
}

model OTP {
  id              BigInt    @id @default(autoincrement())
  phone           String
  otp             String
  expiresAt       DateTime
  verified        Boolean   @default(false)
  createdAt       DateTime  @default(now())
  
  @@index([phone])
  @@map("otps")
}

model Account {
  id              BigInt    @id @default(autoincrement())
  userId          BigInt
  balance         Decimal   @default(100000)
  createdAt       DateTime  @default(now())
  
  user            User      @relation(fields: [userId], references: [id])
  orders          Order[]
  positions       Position[]
  
  @@map("accounts")
}

model Index {
  id              BigInt    @id @default(autoincrement())
  symbol          String    @unique
  displayName     String
  lotSize         Int
  
  @@map("indices")
}

model OptionContract {
  id              BigInt    @id @default(autoincrement())
  tradingSymbol   String    @unique
  indexSymbol     String
  strike          Decimal
  optionType      String    // 'CE' or 'PE'
  expiryDate      String
  lotSize         Int
  
  positions       Position[]
  trades          Trade[]
  
  @@map("option_contracts")
}

model Order {
  id              BigInt    @id @default(autoincrement())
  accountId       BigInt
  tradingSymbol   String
  side            String    // 'BUY' or 'SELL'
  qty             Int
  orderType       String    // 'MARKET', 'LIMIT', 'SL', 'SL-M'
  price           Decimal?
  triggerPrice    Decimal?
  status          String    // 'PENDING', 'EXECUTED', 'CANCELLED'
  filledQty       Int       @default(0)
  avgPrice        Decimal   @default(0)
  createdAt       DateTime  @default(now())
  
  account         Account?  @relation(fields: [accountId], references: [id])
  trades          Trade[]
  
  @@map("orders")
}

model Trade {
  id              BigInt    @id @default(autoincrement())
  orderId         BigInt
  contractId      BigInt
  qty             Int
  price           Decimal
  createdAt       DateTime  @default(now())
  
  order           Order     @relation(fields: [orderId], references: [id])
  contract        OptionContract @relation(fields: [contractId], references: [id])
  
  @@map("trades")
}

model Position {
  id              BigInt    @id @default(autoincrement())
  accountId       BigInt
  contractId      BigInt
  qty             Int       // Positive for long, negative for short
  avgPrice        Decimal
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  
  account         Account   @relation(fields: [accountId], references: [id])
  contract        OptionContract @relation(fields: [contractId], references: [id])
  
  @@unique([accountId, contractId])
  @@map("positions")
}
model AppSettings {
  id                  BigInt   @id @default(autoincrement())
  premiumPrice        Int      @default(99)           // Premium price in INR
  freeCapital         Decimal  @default(100000)       // Free user capital
  premiumCapital      Decimal  @default(1000000)      // Premium user capital
  updatedAt           DateTime @updatedAt
  createdAt           DateTime @default(now())
}
model Announcement {
  id          BigInt   @id @default(autoincrement())
  title       String
  message     String
  targetRole  String   @default("all")  // "all", "premium", "free"
  type        String   @default("info") // "info", "warning", "success"
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  expiresAt   DateTime?
}
</file>

<file path="backend/src/config/constants.ts">
export const INDICES = [
  { symbol: 'NIFTY', displayName: 'NIFTY 50', lotSize: 75 },
  { symbol: 'BANKNIFTY', displayName: 'NIFTY BANK', lotSize: 35 },
  { symbol: 'FINNIFTY', displayName: 'FINNIFTY', lotSize: 65 },
  { symbol: 'MIDCPNIFTY', displayName: 'MIDCAP NIFTY', lotSize: 140 }
];

export const FEES = {
  brokerage: 0.0003,
  exchangeTxn: 0.0005,
  gst: 0.18,
  sebi: 0.000001,
  stampDuty: 0.00003
};

export const CAPITAL = {
  free: 100000,
  premium: 1000000
};

export const TICK_SIZE = 0.05;
</file>

<file path="backend/src/controllers/auth.controller.ts">
import { Router, Request, Response } from 'express';
import { PrismaClient } from '@prisma/client';
import bcrypt from 'bcryptjs';
import jwt from 'jsonwebtoken';
import { CAPITAL } from '../config/constants';

const router = Router();
const prisma = new PrismaClient();

router.post('/register', async (req: Request, res: Response) => {
  try {
    const { email, password } = req.body;

    const existing = await prisma.user.findUnique({ where: { email } });
    if (existing) {
      return res.status(400).json({ error: 'Email already registered' });
    }

    const hash = await bcrypt.hash(password, 10);
    const user = await prisma.user.create({
      data: {
        email,
        hash,
        role: 'free'
      }
    });

    const account = await prisma.account.create({
      data: {
        userId: user.id,
        nickname: 'Default',
        baseCapital: CAPITAL.free
      }
    });

    const token = jwt.sign({ userId: user.id }, process.env.JWT_SECRET!, { expiresIn: '7d' });

    res.json({ 
      token, 
      user: { id: user.id, email: user.email, role: user.role },
      account: { id: account.id, capital: CAPITAL.free }
    });
  } catch (error) {
    console.error('Registration error:', error);
    res.status(500).json({ error: 'Registration failed' });
  }
});

router.post('/login', async (req: Request, res: Response) => {
  try {
    const { email, password } = req.body;

    const user = await prisma.user.findUnique({ 
      where: { email },
      include: { accounts: true }
    });
    
    if (!user) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }

    const valid = await bcrypt.compare(password, user.hash);
    if (!valid) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }

    const token = jwt.sign({ userId: user.id }, process.env.JWT_SECRET!, { expiresIn: '7d' });

    res.json({ 
      token, 
      user: { id: user.id, email: user.email, role: user.role },
      account: user.accounts[0] ? { id: user.accounts[0].id, capital: user.accounts[0].baseCapital } : null
    });
  } catch (error) {
    console.error('Login error:', error);
    res.status(500).json({ error: 'Login failed' });
  }
});

export default router;
</file>

<file path="backend/src/controllers/market.controller.ts">
import { Router, Response } from 'express';
import { PrismaClient } from '@prisma/client';
import { AuthRequest, authenticateToken } from '../middleware/auth.middleware';
import { getQuote } from '../services/quote.service';

const router = Router();
const prisma = new PrismaClient();

router.get('/indices', authenticateToken, async (req: AuthRequest, res: Response) => {
  try {
    const indices = await prisma.index.findMany({
      orderBy: { symbol: 'asc' }
    });
    res.json(indices);
  } catch (error) {
    console.error('Fetch indices error:', error);
    res.status(500).json({ error: 'Failed to fetch indices' });
  }
});

router.get('/option-chain', authenticateToken, async (req: AuthRequest, res: Response) => {
  try {
    const { index, expiry } = req.query;

    if (!index) {
      return res.status(400).json({ error: 'Index required' });
    }

    let query: any = {
      indexSymbol: index as string
    };

    if (expiry) {
      query.expiryDate = new Date(expiry as string);
    }

    const contracts = await prisma.optionContract.findMany({
      where: query,
      orderBy: [
        { expiryDate: 'asc' },
        { strike: 'asc' }
      ],
      take: 100
    });

    if (contracts.length === 0) {
      return res.json({ chain: [], message: 'No contracts found. Please run seed script.' });
    }

    const enriched = await Promise.all(
      contracts.map(async (contract) => {
        const quote = await getQuote(contract.tradingSymbol);
        return {
          id: contract.id.toString(),
          tradingSymbol: contract.tradingSymbol,
          strike: parseFloat(contract.strike.toString()),
          optionType: contract.optionType,
          expiryDate: contract.expiryDate,
          lotSize: contract.lotSize,
          ltp: quote?.ltp || 0,
          bid: quote?.bid || 0,
          ask: quote?.ask || 0,
          volume: quote?.volume || 0,
          oi: quote?.oi || 0
        };
      })
    );

    const grouped: any = {};
    enriched.forEach((contract) => {
      const strike = contract.strike.toString();
      if (!grouped[strike]) {
        grouped[strike] = { strike: contract.strike };
      }
      grouped[strike][contract.optionType] = contract;
    });

    res.json({
      chain: Object.values(grouped),
      expiry: contracts[0]?.expiryDate || null
    });
  } catch (error) {
    console.error('Fetch option chain error:', error);
    res.status(500).json({ error: 'Failed to fetch option chain' });
  }
});

export default router;
</file>

<file path="backend/src/controllers/orders.controller.ts">
import { Router, Response } from 'express';
import { PrismaClient } from '@prisma/client';
import { AuthRequest, authenticateToken } from '../middleware/auth.middleware';
import { placeOrder, cancelOrder } from '../services/order.service';

const router = Router();
const prisma = new PrismaClient();

router.post('/', authenticateToken, async (req: AuthRequest, res: Response) => {
  try {
    const { accountId, tradingSymbol, side, lots, orderType, limitPrice, triggerPrice } = req.body;

    if (!accountId || !tradingSymbol || !side || !lots) {
      return res.status(400).json({ error: 'Missing required fields' });
    }

    const order = await placeOrder({
      accountId,
      tradingSymbol,
      side: side.toUpperCase(),
      lots: parseInt(lots),
      orderType: orderType?.toUpperCase() || 'MARKET',
      limitPrice: limitPrice ? parseFloat(limitPrice) : undefined,
      triggerPrice: triggerPrice ? parseFloat(triggerPrice) : undefined
    });

    res.json({ 
      success: true, 
      order: {
        id: order.id,
        status: order.status,
        side: order.side,
        qty: order.qty
      }
    });
  } catch (error: any) {
    console.error('Place order error:', error);
    res.status(400).json({ error: error.message || 'Failed to place order' });
  }
});

router.get('/', authenticateToken, async (req: AuthRequest, res: Response) => {
  try {
    const { accountId } = req.query;
    
    if (!accountId) {
      return res.status(400).json({ error: 'Account ID required' });
    }

    const orders = await prisma.order.findMany({
      where: { accountId: accountId as string },
      include: { 
        contract: true,
        trades: true
      },
      orderBy: { createdAt: 'desc' },
      take: 50
    });

    const formattedOrders = orders.map(order => ({
      id: order.id,
      tradingSymbol: order.contract.tradingSymbol,
      side: order.side,
      qty: order.qty,
      orderType: order.orderType,
      status: order.status,
      limitPrice: order.limitPrice ? parseFloat(order.limitPrice.toString()) : null,
      createdAt: order.createdAt,
      fills: order.trades.map(trade => ({
        qty: trade.qty,
        price: parseFloat(trade.price.toString()),
        time: trade.tradedAt
      }))
    }));

    res.json(formattedOrders);
  } catch (error) {
    console.error('Fetch orders error:', error);
    res.status(500).json({ error: 'Failed to fetch orders' });
  }
});

router.post('/:id/cancel', authenticateToken, async (req: AuthRequest, res: Response) => {
  try {
    const result = await cancelOrder(req.params.id);
    res.json(result);
  } catch (error: any) {
    console.error('Cancel order error:', error);
    res.status(400).json({ error: error.message || 'Failed to cancel order' });
  }
});

export default router;
</file>

<file path="backend/src/controllers/positions.controller.ts">
import { Router, Response } from 'express';
import { PrismaClient } from '@prisma/client';
import { AuthRequest, authenticateToken } from '../middleware/auth.middleware';
import { getAccountPnL } from '../services/pnl.service';

const router = Router();
const prisma = new PrismaClient();

router.get('/', authenticateToken, async (req: AuthRequest, res: Response) => {
  try {
    const { accountId } = req.query;
    
    if (!accountId) {
      return res.status(400).json({ error: 'Account ID required' });
    }

    const positions = await prisma.position.findMany({
      where: { accountId: accountId as string },
      include: { contract: true }
    });

    const formattedPositions = positions.map(pos => ({
      id: pos.id.toString(),
      tradingSymbol: pos.contract.tradingSymbol,
      optionType: pos.contract.optionType,
      strike: parseFloat(pos.contract.strike.toString()),
      netLots: pos.netLots,
      avgPrice: parseFloat(pos.avgPrice.toString()),
      lotSize: pos.contract.lotSize
    }));

    res.json(formattedPositions);
  } catch (error) {
    console.error('Fetch positions error:', error);
    res.status(500).json({ error: 'Failed to fetch positions' });
  }
});

router.get('/pnl', authenticateToken, async (req: AuthRequest, res: Response) => {
  try {
    const { accountId } = req.query;
    
    if (!accountId) {
      return res.status(400).json({ error: 'Account ID required' });
    }

    const pnl = await getAccountPnL(accountId as string);
    
    const formatted = {
      ...pnl,
      positions: pnl.positions.map(p => ({
        ...p,
        contractId: p.contractId.toString()
      }))
    };

    res.json(formatted);
  } catch (error: any) {
    console.error('Fetch PnL error:', error);
    res.status(500).json({ error: error.message || 'Failed to fetch P&L' });
  }
});

export default router;
</file>

<file path="backend/src/index.ts">
import dotenv from "dotenv";
import path from "path";
import paymentRoutes from "./routes/payment.routes";
import adminRoutes from "./routes/admin.routes";
import publicRoutes from "./routes/public.routes";
// Load environment variables FIRST
dotenv.config({ path: path.join(__dirname, "../.env.local") });

import express, { Application, Request, Response } from "express";
import cors from "cors";

// Import routes - CORRECTED IMPORTS
import authRoutes from "./routes/auth.routes";  // Phone/OTP auth
import marketRoutes from "./routes/market.routes";  // Mock market data
import paperTradingRoutes from "./routes/paper-trading.routes";  // Paper trading

const app: Application = express();

// Middleware
app.use(cors({
  origin: ["http://localhost:3000", "http://localhost:3001"],
  credentials: true,
}));
app.use(express.json());
app.use(express.urlencoded({ extended: true }));
app.use("/api/payment", paymentRoutes);
app.use("/api/admin", adminRoutes);
app.use("/api/public", publicRoutes);
// Health check
app.get("/", (req: Request, res: Response) => {
  res.json({
    message: "PaperBull API - Virtual Trading Platform",
    version: "1.0.0",
    status: "operational"
  });
});

app.get("/health", (req: Request, res: Response) => {
  res.status(200).json({
    status: "OK",
    timestamp: new Date().toISOString(),
  });
});

// API Routes - CORRECTED
app.use("/api/auth", authRoutes);  // Phone/OTP login
app.use("/api/market", marketRoutes);  // Mock market data
app.use("/api/paper-trading", paperTradingRoutes);  // Paper trading orders/portfolio
app.use("/api/payment", paymentRoutes);
app.use("/api/admin", adminRoutes);
// 404 handler
app.use((req: Request, res: Response) => {
  res.status(404).json({
    error: "Route not found",
    path: req.path,
    availableRoutes: [
      "POST /api/auth/send-otp",
      "POST /api/auth/verify-otp",
      "POST /api/auth/register",
      "GET /api/market/option-chain",
      "GET /api/market/status",
      "POST /api/paper-trading/order",
      "GET /api/paper-trading/portfolio",
    ],
  });
});

// Error handler
app.use((err: Error, req: Request, res: Response, next: any) => {
  console.error("Server Error:", err);
  res.status(500).json({
    error: "Internal server error",
    message: err.message,
  });
});

// Start server
const PORT = process.env.PORT || 3001;

app.listen(PORT, () => {
  console.log("=".repeat(70));
  console.log("‚úÖ PaperBull Backend Server Started");
  console.log("=".repeat(70));
  console.log(`üåê Server: http://localhost:${PORT}`);
  console.log(`‚ù§Ô∏è  Health: http://localhost:${PORT}/health`);
  console.log("=".repeat(70));
  console.log("üì± Auth Routes:");
  console.log("   POST /api/auth/send-otp");
  console.log("   POST /api/auth/verify-otp");
  console.log("   POST /api/auth/register");
  console.log("=".repeat(70));
  console.log("üìä Market Routes:");
  console.log("   GET /api/market/option-chain");
  console.log("   GET /api/market/status");
  console.log("=".repeat(70));
  console.log("üí∞ Trading Routes:");
  console.log("   POST /api/paper-trading/order");
  console.log("   GET /api/paper-trading/portfolio");
  console.log("=".repeat(70));
});

export default app;
</file>

<file path="backend/src/routes/admin.routes.ts">
import express, { Request, Response } from "express";
import { PrismaClient } from "@prisma/client";

const router = express.Router();
const prisma = new PrismaClient();

// Simple admin authentication middleware
const adminAuth = (req: Request, res: Response, next: any) => {
  const adminKey = req.headers["x-admin-key"];
  
  // In production, use a secure key from environment variables
  if (adminKey !== process.env.ADMIN_KEY) {
    return res.status(401).json({ error: "Unauthorized" });
  }
  
  next();
};

// Dashboard Overview
router.get("/dashboard", adminAuth, async (req: Request, res: Response) => {
  try {
    // Total users
    const totalUsers = await prisma.user.count();
    
    // Premium vs Free users
    const premiumUsers = await prisma.user.count({
      where: { role: "premium" },
    });
    const freeUsers = await prisma.user.count({
      where: { role: "free" },
    });
    
    // Recent registrations (last 7 days)
    const sevenDaysAgo = new Date();
    sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);
    
    const recentUsers = await prisma.user.count({
      where: {
        createdAt: {
          gte: sevenDaysAgo,
        },
      },
    });
    
    // Total capital deployed (sum of all account balances)
    const accounts = await prisma.account.findMany({
      select: { balance: true },
    });
    const totalCapital = accounts.reduce((sum, acc) => sum + Number(acc.balance), 0);
    
    // Active users (users who logged in in last 30 days)
    const thirtyDaysAgo = new Date();
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
    
    const activeUsers = await prisma.user.count({
      where: {
        createdAt: {
          gte: thirtyDaysAgo,
        },
      },
    });

    res.json({
      overview: {
        totalUsers,
        premiumUsers,
        freeUsers,
        recentUsers,
        activeUsers,
        totalCapital,
      },
      timestamp: new Date(),
    });
  } catch (error) {
    console.error("Dashboard error:", error);
    res.status(500).json({ error: "Failed to load dashboard" });
  }
});

// Get all users with details
router.get("/users", adminAuth, async (req: Request, res: Response) => {
  try {
    const { page = 1, limit = 20, role, search } = req.query;
    
    const skip = (Number(page) - 1) * Number(limit);
    
    const where: any = {};
    
    if (role && role !== "all") {
      where.role = role;
    }
    
    if (search) {
      where.OR = [
        { username: { contains: String(search), mode: "insensitive" } },
        { phone: { contains: String(search) } },
        { email: { contains: String(search), mode: "insensitive" } },
      ];
    }
    
    const users = await prisma.user.findMany({
      where,
      include: {
        accounts: true,
      },
      skip,
      take: Number(limit),
      orderBy: { createdAt: "desc" },
    });
    
    const total = await prisma.user.count({ where });
    
    res.json({
      users: users.map((u) => ({
        id: u.id.toString(),
        username: u.username,
        phone: u.phone,
        email: u.email,
        role: u.role,
        balance: u.accounts[0]?.balance.toString() || "0",
        createdAt: u.createdAt,
      })),
      pagination: {
        total,
        page: Number(page),
        limit: Number(limit),
        totalPages: Math.ceil(total / Number(limit)),
      },
    });
  } catch (error) {
    console.error("Get users error:", error);
    res.status(500).json({ error: "Failed to get users" });
  }
});

// Get user details by ID
router.get("/users/:id", adminAuth, async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    
    const user = await prisma.user.findUnique({
      where: { id: BigInt(id) },
      include: {
        accounts: true,
      },
    });
    
    if (!user) {
      return res.status(404).json({ error: "User not found" });
    }
    
    res.json({
      id: user.id.toString(),
      username: user.username,
      phone: user.phone,
      email: user.email,
      role: user.role,
      createdAt: user.createdAt,
      account: user.accounts[0]
        ? {
            id: user.accounts[0].id.toString(),
            balance: user.accounts[0].balance.toString(),
          }
        : null,
    });
  } catch (error) {
    console.error("Get user error:", error);
    res.status(500).json({ error: "Failed to get user" });
  }
});

// Update user role (upgrade/downgrade)
router.patch("/users/:id/role", adminAuth, async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const { role } = req.body;
    
    if (!["free", "premium"].includes(role)) {
      return res.status(400).json({ error: "Invalid role" });
    }
    
    const user = await prisma.user.update({
      where: { id: BigInt(id) },
      data: { role },
    });
    
    // Update account balance based on role
    const newBalance = role === "premium" ? 1000000 : 100000;
    
    await prisma.account.updateMany({
      where: { userId: BigInt(id) },
      data: { balance: newBalance },
    });
    
    res.json({
      success: true,
      message: `User upgraded to ${role}`,
      user: {
        id: user.id.toString(),
        role: user.role,
      },
    });
  } catch (error) {
    console.error("Update role error:", error);
    res.status(500).json({ error: "Failed to update role" });
  }
});

// Get revenue statistics
router.get("/revenue", adminAuth, async (req: Request, res: Response) => {
  try {
    const premiumCount = await prisma.user.count({
      where: { role: "premium" },
    });
    
    const monthlyRevenue = premiumCount * 99;
    const yearlyRevenue = monthlyRevenue * 12;
    
    res.json({
      premiumSubscribers: premiumCount,
      monthlyRevenue,
      yearlyRevenue,
      pricePerUser: 99,
    });
  } catch (error) {
    console.error("Revenue error:", error);
    res.status(500).json({ error: "Failed to get revenue" });
  }
});

// Delete user (with confirmation)
router.delete("/users/:id", adminAuth, async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    
    // Delete user's accounts first (foreign key constraint)
    await prisma.account.deleteMany({
      where: { userId: BigInt(id) },
    });
    
    // Delete user
    await prisma.user.delete({
      where: { id: BigInt(id) },
    });
    
    res.json({
      success: true,
      message: "User deleted successfully",
    });
  } catch (error) {
    console.error("Delete user error:", error);
    res.status(500).json({ error: "Failed to delete user" });
  }
});

// Get app statistics (growth over time)
router.get("/stats/growth", adminAuth, async (req: Request, res: Response) => {
  try {
    // Users registered per day for last 30 days
    const thirtyDaysAgo = new Date();
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
    
    const users = await prisma.user.findMany({
      where: {
        createdAt: {
          gte: thirtyDaysAgo,
        },
      },
      select: {
        createdAt: true,
        role: true,
      },
      orderBy: { createdAt: "asc" },
    });
    
    // Group by date
    const groupedByDate: Record<string, { free: number; premium: number }> = {};
    
    users.forEach((user) => {
      const date = user.createdAt.toISOString().split("T")[0];
      if (!groupedByDate[date]) {
        groupedByDate[date] = { free: 0, premium: 0 };
      }
      groupedByDate[date][user.role as "free" | "premium"]++;
    });
    
    res.json({
      dailyGrowth: Object.entries(groupedByDate).map(([date, counts]) => ({
        date,
        free: counts.free,
        premium: counts.premium,
        total: counts.free + counts.premium,
      })),
    });
  } catch (error) {
    console.error("Growth stats error:", error);
    res.status(500).json({ error: "Failed to get growth stats" });
  }
});
// Get app settings
router.get("/settings", adminAuth, async (req: Request, res: Response) => {
  try {
    let settings = await prisma.appSettings.findFirst();
    
    // Create default settings if none exist
    if (!settings) {
      settings = await prisma.appSettings.create({
        data: {
          premiumPrice: 99,
          freeCapital: 100000,
          premiumCapital: 1000000,
        },
      });
    }
    
    res.json({
      premiumPrice: settings.premiumPrice,
      freeCapital: settings.freeCapital.toString(),
      premiumCapital: settings.premiumCapital.toString(),
      updatedAt: settings.updatedAt,
    });
  } catch (error) {
    console.error("Get settings error:", error);
    res.status(500).json({ error: "Failed to get settings" });
  }
});

// Update app settings
router.patch("/settings", adminAuth, async (req: Request, res: Response) => {
  try {
    const { premiumPrice, freeCapital, premiumCapital } = req.body;
    
    // Validate inputs
    if (premiumPrice !== undefined && (premiumPrice < 0 || premiumPrice > 10000)) {
      return res.status(400).json({ error: "Premium price must be between 0 and 10000" });
    }
    
    if (freeCapital !== undefined && (freeCapital < 10000 || freeCapital > 10000000)) {
      return res.status(400).json({ error: "Free capital must be between 10,000 and 1,00,00,000" });
    }
    
    if (premiumCapital !== undefined && (premiumCapital < 10000 || premiumCapital > 100000000)) {
      return res.status(400).json({ error: "Premium capital must be between 10,000 and 10,00,00,000" });
    }
    
    // Get or create settings
    let settings = await prisma.appSettings.findFirst();
    
    if (!settings) {
      settings = await prisma.appSettings.create({
        data: {
          premiumPrice: premiumPrice || 99,
          freeCapital: freeCapital || 100000,
          premiumCapital: premiumCapital || 1000000,
        },
      });
    } else {
      settings = await prisma.appSettings.update({
        where: { id: settings.id },
        data: {
          ...(premiumPrice !== undefined && { premiumPrice }),
          ...(freeCapital !== undefined && { freeCapital }),
          ...(premiumCapital !== undefined && { premiumCapital }),
        },
      });
    }
    
    console.log("Settings updated:", {
      premiumPrice: settings.premiumPrice,
      freeCapital: settings.freeCapital.toString(),
      premiumCapital: settings.premiumCapital.toString(),
    });
    
    res.json({
      success: true,
      message: "Settings updated successfully",
      settings: {
        premiumPrice: settings.premiumPrice,
        freeCapital: settings.freeCapital.toString(),
        premiumCapital: settings.premiumCapital.toString(),
      },
    });
  } catch (error) {
    console.error("Update settings error:", error);
    res.status(500).json({ error: "Failed to update settings" });
  }
});
// Get all announcements
router.get("/announcements", adminAuth, async (req: Request, res: Response) => {
  try {
    const announcements = await prisma.announcement.findMany({
      orderBy: { createdAt: "desc" },
    });
    
    res.json({
      announcements: announcements.map((a) => ({
        id: a.id.toString(),
        title: a.title,
        message: a.message,
        targetRole: a.targetRole,
        type: a.type,
        isActive: a.isActive,
        createdAt: a.createdAt,
        expiresAt: a.expiresAt,
      })),
    });
  } catch (error) {
    console.error("Get announcements error:", error);
    res.status(500).json({ error: "Failed to get announcements" });
  }
});

// Create announcement
router.post("/announcements", adminAuth, async (req: Request, res: Response) => {
  try {
    const { title, message, targetRole, type, expiresAt } = req.body;
    
    if (!title || !message) {
      return res.status(400).json({ error: "Title and message required" });
    }
    
    if (!["all", "premium", "free"].includes(targetRole)) {
      return res.status(400).json({ error: "Invalid target role" });
    }
    
    if (!["info", "warning", "success"].includes(type)) {
      return res.status(400).json({ error: "Invalid type" });
    }
    
    const announcement = await prisma.announcement.create({
      data: {
        title,
        message,
        targetRole,
        type,
        expiresAt: expiresAt ? new Date(expiresAt) : null,
      },
    });
    
    console.log("Announcement created:", announcement.title);
    
    res.json({
      success: true,
      announcement: {
        id: announcement.id.toString(),
        title: announcement.title,
        message: announcement.message,
        targetRole: announcement.targetRole,
        type: announcement.type,
        isActive: announcement.isActive,
      },
    });
  } catch (error) {
    console.error("Create announcement error:", error);
    res.status(500).json({ error: "Failed to create announcement" });
  }
});

// Toggle announcement active status
router.patch("/announcements/:id/toggle", adminAuth, async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    
    const announcement = await prisma.announcement.findUnique({
      where: { id: BigInt(id) },
    });
    
    if (!announcement) {
      return res.status(404).json({ error: "Announcement not found" });
    }
    
    const updated = await prisma.announcement.update({
      where: { id: BigInt(id) },
      data: { isActive: !announcement.isActive },
    });
    
    res.json({
      success: true,
      isActive: updated.isActive,
    });
  } catch (error) {
    console.error("Toggle announcement error:", error);
    res.status(500).json({ error: "Failed to toggle announcement" });
  }
});

// Delete announcement
router.delete("/announcements/:id", adminAuth, async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    
    await prisma.announcement.delete({
      where: { id: BigInt(id) },
    });
    
    res.json({
      success: true,
      message: "Announcement deleted",
    });
  } catch (error) {
    console.error("Delete announcement error:", error);
    res.status(500).json({ error: "Failed to delete announcement" });
  }
});


export default router;
</file>

<file path="backend/src/routes/auth.routes.ts">
import express, { Request, Response } from "express";
import { PrismaClient } from "@prisma/client";
import jwt from "jsonwebtoken";

const router = express.Router();
const prisma = new PrismaClient();

// Store OTPs in memory (in production, use Redis)
const otpStore = new Map<string, { otp: string; expiresAt: Date }>();

// Send OTP
router.post("/send-otp", async (req: Request, res: Response) => {
  try {
    const { phone } = req.body;

    console.log("Send OTP request for:", phone);

    if (!phone || phone.length !== 10) {
      return res.status(400).json({ error: "Invalid phone number" });
    }

    const user = await prisma.user.findUnique({ where: { phone } });

    if (!user) {
      console.log("User not found, needs registration");
      return res.status(404).json({ 
        error: "User not found",
        needsRegistration: true 
      });
    }

    const otp = Math.floor(100000 + Math.random() * 900000).toString();
    const expiresAt = new Date(Date.now() + 5 * 60 * 1000);

    otpStore.set(phone, { otp, expiresAt });

    console.log(`üîê OTP for ${phone}: ${otp}`);

    res.json({ 
      success: true, 
      message: "OTP sent successfully",
      otp: process.env.NODE_ENV === "development" ? otp : undefined
    });
  } catch (error) {
    console.error("Send OTP error:", error);
    res.status(500).json({ error: "Failed to send OTP" });
  }
});

// Verify OTP and Login
router.post("/verify-otp", async (req: Request, res: Response) => {
  try {
    const { phone, otp } = req.body;

    console.log("Verify OTP request:", { phone, otp });

    const storedOTP = otpStore.get(phone);
    
    if (!storedOTP) {
      console.log("OTP not found for phone:", phone);
      return res.status(400).json({ error: "OTP expired or not found. Please request a new OTP." });
    }

    if (storedOTP.expiresAt < new Date()) {
      console.log("OTP expired for phone:", phone);
      otpStore.delete(phone);
      return res.status(400).json({ error: "OTP expired. Please request a new OTP." });
    }

    if (storedOTP.otp !== otp) {
      console.log("Invalid OTP. Expected:", storedOTP.otp, "Got:", otp);
      return res.status(400).json({ error: "Invalid OTP" });
    }

    console.log("OTP verified successfully");

    otpStore.delete(phone);

    const user = await prisma.user.findUnique({
      where: { phone },
      include: { accounts: true },
    });

    if (!user) {
      return res.status(404).json({ error: "User not found" });
    }

    const token = jwt.sign(
      { userId: user.id.toString() },
      process.env.JWT_SECRET || "your-secret-key",
      { expiresIn: "7d" }
    );

    console.log("Login successful for user:", user.username);

    res.json({
      token,
      user: {
        id: user.id.toString(),
        phone: user.phone,
        username: user.username,
        role: user.role,
      },
      account: user.accounts[0]
        ? {
            id: user.accounts[0].id.toString(),
            balance: user.accounts[0].balance.toString(),
          }
        : null,
    });
  } catch (error) {
    console.error("Verify OTP error:", error);
    res.status(500).json({ error: "Verification failed" });
  }
});

// Register new user
// Register new user
router.post("/register", async (req: Request, res: Response) => {
  try {
    const { phone, username, role } = req.body;

    console.log("Register request:", { phone, username, role });

    if (!phone || !username) {
      return res.status(400).json({ error: "Phone and name required" });
    }

    const existing = await prisma.user.findUnique({ where: { phone } });
    if (existing) {
      return res.status(400).json({ error: "User already registered" });
    }

    // Get settings for initial capital
    let settings = await prisma.appSettings.findFirst();
    if (!settings) {
      settings = await prisma.appSettings.create({
        data: {
          premiumPrice: 99,
          freeCapital: 100000,
          premiumCapital: 1000000,
        },
      });
    }

    const initialCapital = role === "premium" 
      ? Number(settings.premiumCapital) 
      : Number(settings.freeCapital);

    const user = await prisma.user.create({
      data: {
        phone,
        username,
        email: `${phone}@paperbull.com`,
        role: role || "free",
      },
    });

    await prisma.account.create({
      data: {
        userId: user.id,
        balance: initialCapital,
      },
    });

    console.log("User registered successfully:", username);

    res.json({
      success: true,
      message: "Registration successful",
    });
  } catch (error) {
    console.error("Registration error:", error);
    res.status(500).json({ error: "Registration failed" });
  }
});


export default router;  // ‚Üê MAKE SURE THIS LINE IS AT THE END
</file>

<file path="backend/src/routes/market-data.routes.ts">
import express from 'express';
import { upstoxService } from '../services/upstox.service';

const router = express.Router();

router.get('/quote', async (req, res) => {
  try {
    const { symbols } = req.query;
    
    if (!symbols || typeof symbols !== 'string') {
      return res.status(400).json({ 
        error: 'symbols parameter required',
        example: '/api/market-data/quote?symbols=NSE_EQ|INE002A01018'
      });
    }

    const symbolArray = symbols.split(',');
    const data = await upstoxService.getMarketQuote(symbolArray);
    res.json(data);
  } catch (error: any) {
    res.status(500).json({ 
      error: error.message,
      hint: error.message.includes('Not authenticated') 
        ? 'Visit /auth/upstox/login to authenticate' 
        : undefined
    });
  }
});

router.get('/ltp', async (req, res) => {
  try {
    const { symbols } = req.query;
    
    if (!symbols || typeof symbols !== 'string') {
      return res.status(400).json({ 
        error: 'symbols parameter required',
        example: '/api/market-data/ltp?symbols=NSE_EQ|INE002A01018,NSE_EQ|INE467B01029'
      });
    }

    const symbolArray = symbols.split(',');
    const data = await upstoxService.getLTP(symbolArray);
    res.json(data);
  } catch (error: any) {
    res.status(500).json({ error: error.message });
  }
});

router.get('/option-chain', async (req, res) => {
  try {
    const { instrument_key, expiry_date } = req.query;
    
    if (!instrument_key || !expiry_date) {
      return res.status(400).json({ 
        error: 'instrument_key and expiry_date required',
        example: '/api/market-data/option-chain?instrument_key=NSE_INDEX|Nifty%2050&expiry_date=2025-11-28'
      });
    }

    const data = await upstoxService.getOptionChain(
      instrument_key as string,
      expiry_date as string
    );
    res.json(data);
  } catch (error: any) {
    res.status(500).json({ error: error.message });
  }
});

router.get('/historical', async (req, res) => {
  try {
    const { instrument_key, interval, from, to } = req.query;
    
    if (!instrument_key || !interval || !from || !to) {
      return res.status(400).json({ 
        error: 'All parameters required',
        example: '/api/market-data/historical?instrument_key=NSE_EQ|INE002A01018&interval=1day&from=2025-11-01&to=2025-11-15'
      });
    }

    const data = await upstoxService.getHistoricalData(
      instrument_key as string,
      interval as string,
      to as string,
      from as string
    );
    res.json(data);
  } catch (error: any) {
    res.status(500).json({ error: error.message });
  }
});

export default router;
</file>

<file path="backend/src/routes/market.routes.ts">
import express from 'express';

const router = express.Router();

// Route 1: Option chain data (fixes your first 404 error)
router.get('/option-chain', async (req, res) => {
  try {
    const { index } = req.query;
    
    if (!index) {
      return res.status(400).json({ 
        error: 'Index parameter is required',
        message: 'Please provide an index (e.g., NIFTY, BANKNIFTY)' 
      });
    }

    console.log(`üìä Fetching option chain for: ${index}`);

    const basePrice = index === 'NIFTY' ? 19850 : 45200;
    const strikeInterval = index === 'NIFTY' ? 50 : 100;
    const numberOfStrikes = 21;
    
    const chain = [];
    const startStrike = basePrice - (Math.floor(numberOfStrikes / 2) * strikeInterval);

    for (let i = 0; i < numberOfStrikes; i++) {
      const strike = startStrike + (i * strikeInterval);
      
      chain.push({
        strike: strike,
        CE: {
          tradingSymbol: `${index}${strike}CE`,
          strike: strike,
          optionType: 'CE',
          ltp: Math.random() * 200 + 50,
          bid: Math.random() * 190 + 45,
          ask: Math.random() * 210 + 55,
          volume: Math.floor(Math.random() * 500000) + 50000,
          oi: Math.floor(Math.random() * 5000000) + 500000,
          lotSize: index === 'NIFTY' ? 50 : 25,
          changePercent: (Math.random() - 0.5) * 20
        },
        PE: {
          tradingSymbol: `${index}${strike}PE`,
          strike: strike,
          optionType: 'PE',
          ltp: Math.random() * 200 + 50,
          bid: Math.random() * 190 + 45,
          ask: Math.random() * 210 + 55,
          volume: Math.floor(Math.random() * 500000) + 50000,
          oi: Math.floor(Math.random() * 5000000) + 500000,
          lotSize: index === 'NIFTY' ? 50 : 25,
          changePercent: (Math.random() - 0.5) * 20
        }
      });
    }

    const response = {
      index: index,
      chain: chain,
      timestamp: new Date().toISOString(),
      underlyingPrice: basePrice,
      success: true
    };

    console.log(`‚úÖ Returning ${chain.length} strikes for ${index}`);
    res.json(response);

  } catch (error) {
    console.error('‚ùå Error fetching option chain:', error);
    res.status(500).json({ 
      error: 'Failed to fetch option chain data',
      message: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

// Route 2: Market status
router.get('/status', async (req, res) => {
  try {
    res.json({
      marketStatus: 'OPEN',
      currentTime: new Date().toISOString(),
      tradingHours: {
        open: '09:15',
        close: '15:30'
      }
    });
  } catch (error) {
    console.error('Error fetching market status:', error);
    res.status(500).json({ error: 'Failed to fetch market status' });
  }
});

export default router;
</file>

<file path="backend/src/routes/order.routes.ts">
import express from 'express';
import { upstoxService } from '../services/upstox.service';

const router = express.Router();

// Place a new order
router.post('/place', async (req, res) => {
  try {
    const orderData = req.body;
    const result = await upstoxService.placeOrder(orderData);
    res.json(result);
  } catch (error: any) {
    res.status(500).json({ 
      error: 'Failed to place order',
      message: error.message 
    });
  }
});

// Get all orders
router.get('/', async (req, res) => {
  try {
    const orders = await upstoxService.getOrders();
    res.json(orders);
  } catch (error: any) {
    res.status(500).json({ 
      error: 'Failed to fetch orders',
      message: error.message 
    });
  }
});

export default router;
</file>

<file path="backend/src/routes/paper-trading.routes.ts">
import express from 'express';

const router = express.Router();

// In-memory storage (replace with database in production)
let portfolio = {
  balance: 1000000, // ‚Çπ10 lakh starting capital
  positions: [] as any[],
  orders: [] as any[]
};

// Get portfolio
router.get('/portfolio', (req, res) => {
  try {
    const totalPnL = portfolio.positions.reduce((sum, pos) => {
      return sum + (pos.quantity * (pos.currentPrice - pos.avgPrice));
    }, 0);

    res.json({
      balance: portfolio.balance,
      positions: portfolio.positions,
      totalPnL,
      totalValue: portfolio.balance + totalPnL
    });
  } catch (error: any) {
    console.error('Portfolio error:', error);
    res.status(500).json({ error: error.message });
  }
});

// Place order - THIS IS THE FIX
router.post('/order', (req, res) => {
  try {
    console.log('Received order:', req.body);

    const { symbol, quantity, price, side, type } = req.body;

    // Validate input
    if (!symbol || !quantity || !price || !side) {
      return res.status(400).json({ 
        error: 'Missing required fields: symbol, quantity, price, side' 
      });
    }

    // Create order object
    const order = {
      id: `ORDER_${Date.now()}`,
      symbol,
      quantity,
      price,
      side,
      type: type || 'MARKET',
      status: 'COMPLETED',
      timestamp: new Date().toISOString()
    };

    // Calculate order value
    const orderValue = quantity * price;

    // Check if user has enough balance for BUY orders
    if (side === 'BUY' && orderValue > portfolio.balance) {
      return res.status(400).json({ 
        error: 'Insufficient balance',
        required: orderValue,
        available: portfolio.balance
      });
    }

    // Update balance
    if (side === 'BUY') {
      portfolio.balance -= orderValue;
    } else if (side === 'SELL') {
      portfolio.balance += orderValue;
    }

    // Update positions
    const existingPositionIndex = portfolio.positions.findIndex(
      pos => pos.symbol === symbol
    );

    if (existingPositionIndex >= 0) {
      // Update existing position
      const pos = portfolio.positions[existingPositionIndex];
      
      if (side === 'BUY') {
        const totalQty = pos.quantity + quantity;
        pos.avgPrice = ((pos.avgPrice * pos.quantity) + (price * quantity)) / totalQty;
        pos.quantity = totalQty;
      } else if (side === 'SELL') {
        pos.quantity -= quantity;
        
        // Remove position if quantity becomes zero
        if (pos.quantity <= 0) {
          portfolio.positions.splice(existingPositionIndex, 1);
        }
      }
    } else if (side === 'BUY') {
      // Create new position
      portfolio.positions.push({
        symbol,
        quantity,
        avgPrice: price,
        currentPrice: price,
        pnl: 0
      });
    }

    // Add to orders history
    portfolio.orders.push(order);

    console.log('‚úÖ Order placed successfully:', order);
    console.log('üìä Updated portfolio:', {
      balance: portfolio.balance,
      positions: portfolio.positions.length
    });

    res.json({
      success: true,
      order,
      portfolio: {
        balance: portfolio.balance,
        positions: portfolio.positions
      }
    });
  } catch (error: any) {
    console.error('‚ùå Order placement error:', error);
    res.status(500).json({ 
      error: 'Internal server error',
      message: error.message 
    });
  }
});

// Get orders
router.get('/orders', (req, res) => {
  try {
    res.json({
      orders: portfolio.orders
    });
  } catch (error: any) {
    console.error('Orders error:', error);
    res.status(500).json({ error: error.message });
  }
});

// Get positions
router.get('/positions', (req, res) => {
  try {
    res.json({
      positions: portfolio.positions
    });
  } catch (error: any) {
    console.error('Positions error:', error);
    res.status(500).json({ error: error.message });
  }
});

// Reset portfolio (for testing)
router.post('/reset', (req, res) => {
  try {
    portfolio = {
      balance: 1000000,
      positions: [],
      orders: []
    };
    
    res.json({ 
      success: true,
      message: 'Portfolio reset to ‚Çπ10,00,000',
      portfolio 
    });
  } catch (error: any) {
    console.error('Reset error:', error);
    res.status(500).json({ error: error.message });
  }
});

export default router;
</file>

<file path="backend/src/routes/payment.routes.ts">
import express, { Request, Response } from "express";
import { PrismaClient } from "@prisma/client";

const router = express.Router();
const prisma = new PrismaClient();

// Store verified payments (in production, use database)
const verifiedPayments = new Set<string>();

// Verify payment (manual verification for now)
router.post("/verify", async (req: Request, res: Response) => {
  try {
    const { phone, transactionId, amount } = req.body;

    console.log("Payment verification request:", { phone, transactionId, amount });

    if (!transactionId || transactionId.length < 12) {
      return res.status(400).json({ error: "Invalid transaction ID" });
    }

    // Check if already verified
    if (verifiedPayments.has(transactionId)) {
      return res.status(400).json({ error: "Transaction already verified" });
    }

    // In production: Verify with payment gateway API
    // For now: Manual verification (approve all for testing)
    
    // Mark as verified
    verifiedPayments.add(transactionId);

    // Log payment in database
    console.log(`‚úÖ Payment verified: ${transactionId} for phone: ${phone}`);

    res.json({
      success: true,
      message: "Payment verified successfully",
      transactionId,
    });
  } catch (error) {
    console.error("Payment verification error:", error);
    res.status(500).json({ error: "Payment verification failed" });
  }
});

// Get payment status
router.get("/status/:transactionId", async (req: Request, res: Response) => {
  try {
    const { transactionId } = req.params;
    const verified = verifiedPayments.has(transactionId);

    res.json({
      verified,
      transactionId,
    });
  } catch (error) {
    console.error("Status check error:", error);
    res.status(500).json({ error: "Failed to check status" });
  }
});

export default router;
</file>

<file path="backend/src/routes/position.routes.ts">
import express from 'express';
import { upstoxService } from '../services/upstox.service';

const router = express.Router();

// Get all positions
router.get('/', async (req, res) => {
  try {
    const positions = await upstoxService.getPositions();
    res.json(positions);
  } catch (error: any) {
    res.status(500).json({ 
      error: 'Failed to fetch positions',
      message: error.message 
    });
  }
});

export default router;
</file>

<file path="backend/src/routes/public.routes.ts">
import express, { Request, Response } from "express";
import { PrismaClient } from "@prisma/client";

const router = express.Router();
const prisma = new PrismaClient();

// Get active announcements for a specific user role
router.get("/announcements", async (req: Request, res: Response) => {
  try {
    const { role } = req.query;
    
    const now = new Date();
    
    const announcements = await prisma.announcement.findMany({
      where: {
        isActive: true,
        OR: [
          { targetRole: "all" },
          { targetRole: role as string },
        ],
        AND: [
          {
            OR: [
              { expiresAt: null },
              { expiresAt: { gt: now } },
            ],
          },
        ],
      },
      orderBy: { createdAt: "desc" },
    });
    
    res.json({
      announcements: announcements.map((a) => ({
        id: a.id.toString(),
        title: a.title,
        message: a.message,
        type: a.type,
        createdAt: a.createdAt,
      })),
    });
  } catch (error) {
    console.error("Get announcements error:", error);
    res.status(500).json({ error: "Failed to get announcements" });
  }
});

export default router;
</file>

<file path="backend/src/seed.ts">
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

async function seedIndices() {
  console.log('üå± Seeding indices...');
  
  const indices = [
    { symbol: 'NIFTY', displayName: 'NIFTY 50', lotSize: 75 },
    { symbol: 'BANKNIFTY', displayName: 'NIFTY BANK', lotSize: 25 },
    { symbol: 'FINNIFTY', displayName: 'FINNIFTY', lotSize: 40 },
    { symbol: 'MIDCPNIFTY', displayName: 'MIDCAP NIFTY', lotSize: 50 },
    { symbol: 'SENSEX', displayName: 'SENSEX', lotSize: 10 },
    { symbol: 'NIFTYIT', displayName: 'NIFTY IT', lotSize: 25 },
    { symbol: 'NIFTYPHARMA', displayName: 'NIFTY PHARMA', lotSize: 20 },
  ];

  for (const index of indices) {
    await prisma.index.upsert({
      where: { symbol: index.symbol },
      update: index,
      create: index
    });
  }
  
  console.log('‚úì Indices seeded - 7 indices created');
}

async function seedOptionContracts() {
  const indices = await prisma.index.findMany();
  
  for (const index of indices) {
    console.log(`üå± Seeding ${index.displayName} contracts...`);
    
    const basePrices: Record<string, number> = {
      'NIFTY': 25000,
      'BANKNIFTY': 55000,
      'FINNIFTY': 23500,
      'MIDCPNIFTY': 14500,
      'SENSEX': 84000,
      'NIFTYIT': 42000,
      'NIFTYPHARMA': 22000,
    };
    
    const basePrice = basePrices[index.symbol] || 25000;
    const atmStrike = Math.round(basePrice / 100) * 100;
    
    const strikes = [];
    const strikeInterval = index.symbol === 'SENSEX' ? 100 : 50;
    
    for (let i = -10; i <= 10; i++) {
      strikes.push(atmStrike + (i * strikeInterval));
    }
    
    const today = new Date();
    const daysUntilThursday = (4 - today.getDay() + 7) % 7 || 7;
    const expiry = new Date(today);
    expiry.setDate(today.getDate() + daysUntilThursday);
    expiry.setHours(15, 30, 0, 0);
    
    const expiryDateString = expiry.toISOString();
    
    for (const strike of strikes) {
      // CE (Call)
      try {
        await prisma.optionContract.upsert({
          where: {
            tradingSymbol: `${index.symbol}${expiry.getDate()}${expiry.toLocaleString('en-US', { month: 'short' }).toUpperCase()}${strike}CE`
          },
          update: {},
          create: {
            tradingSymbol: `${index.symbol}${expiry.getDate()}${expiry.toLocaleString('en-US', { month: 'short' }).toUpperCase()}${strike}CE`,
            indexSymbol: index.symbol,
            strike,
            optionType: 'CE',
            expiryDate: expiryDateString,
            lotSize: index.lotSize,
          }
        });
      } catch (error) {
        console.log(`Skipping ${index.symbol} ${strike}CE - already exists`);
      }
      
      // PE (Put)
      try {
        await prisma.optionContract.upsert({
          where: {
            tradingSymbol: `${index.symbol}${expiry.getDate()}${expiry.toLocaleString('en-US', { month: 'short' }).toUpperCase()}${strike}PE`
          },
          update: {},
          create: {
            tradingSymbol: `${index.symbol}${expiry.getDate()}${expiry.toLocaleString('en-US', { month: 'short' }).toUpperCase()}${strike}PE`,
            indexSymbol: index.symbol,
            strike,
            optionType: 'PE',
            expiryDate: expiryDateString,
            lotSize: index.lotSize,
          }
        });
      } catch (error) {
        console.log(`Skipping ${index.symbol} ${strike}PE - already exists`);
      }
    }
    
    console.log(`‚úì ${index.displayName} contracts seeded`);
  }
}

async function main() {
  console.log('üå± Starting database seed...\n');
  
  try {
    await seedIndices();
    await seedOptionContracts();
    
    console.log('\n‚úÖ Seed completed successfully!');
    console.log('üìä You can now use the trading app.\n');
  } catch (error) {
    console.error('‚ùå Error during seed:', error);
    throw error;
  } finally {
    await prisma.$disconnect();
  }
}

main()
  .catch((e) => {
    console.error(e);
    process.exit(1);
  });
</file>

<file path="backend/src/services/market-data.service.ts">
import axios from 'axios';

export class MarketDataService {
  private apiKey: string;
  private apiSecret: string;
  private baseUrl: string;

  constructor() {
    this.apiKey = process.env.API_KEY || '';
    this.apiSecret = process.env.API_SECRET || '';
    this.baseUrl = process.env.API_BASE_URL || '';
  }

  // Fetch current market price
  async getCurrentPrice(symbol: string): Promise<number> {
    try {
      const response = await axios.get(`${this.baseUrl}/price`, {
        params: { symbol },
        headers: {
          'X-API-Key': this.apiKey,
          'X-API-Secret': this.apiSecret
        }
      });
      return response.data.price;
    } catch (error) {
      console.error('Error fetching price:', error);
      throw error;
    }
  }

  // Fetch historical data
  async getHistoricalData(symbol: string, interval: string) {
    const response = await axios.get(`${this.baseUrl}/historical`, {
      params: { symbol, interval },
      headers: {
        'X-API-Key': this.apiKey
      }
    });
    return response.data;
  }
}
</file>

<file path="backend/src/services/order.service.ts">
import { PrismaClient } from '@prisma/client';
import { getLTP } from './quote.service';
import { calculateFees, roundToTick } from '../utils/helpers';
import { broadcastPnL } from './pnl.service';

const prisma = new PrismaClient();

export interface PlaceOrderParams {
  accountId: string;
  tradingSymbol: string;
  side: 'BUY' | 'SELL';
  lots: number;
  orderType: 'MARKET' | 'LIMIT' | 'SL' | 'SLM';
  limitPrice?: number;
  triggerPrice?: number;
}

export async function placeOrder(params: PlaceOrderParams) {
  const contract = await prisma.optionContract.findUnique({
    where: { tradingSymbol: params.tradingSymbol }
  });

  if (!contract) {
    throw new Error('Contract not found');
  }

  const order = await prisma.order.create({
    data: {
      accountId: params.accountId,
      contractId: contract.id,
      side: params.side,
      qty: params.lots,
      orderType: params.orderType,
      limitPrice: params.limitPrice,
      triggerPrice: params.triggerPrice,
      status: 'OPEN'
    }
  });

  await attemptFill(order.id);
  return order;
}

export async function attemptFill(orderId: string) {
  const order = await prisma.order.findUnique({
    where: { id: orderId },
    include: { contract: true }
  });

  if (!order || order.status !== 'OPEN') {
    return;
  }

  const ltp = await getLTP(order.contract.tradingSymbol);
  if (!ltp) {
    return;
  }

  let fillPrice: number | null = null;

  if (order.orderType === 'MARKET') {
    fillPrice = ltp;
  } else if (order.orderType === 'LIMIT' && order.limitPrice) {
    const limit = parseFloat(order.limitPrice.toString());
    if (
      (order.side === 'BUY' && ltp <= limit) ||
      (order.side === 'SELL' && ltp >= limit)
    ) {
      fillPrice = limit;
    }
  }

  if (fillPrice) {
    await executeFill(order.id, order.qty, roundToTick(fillPrice));
  }
}

async function executeFill(orderId: string, lots: number, price: number) {
  const order = await prisma.order.findUnique({
    where: { id: orderId },
    include: { contract: true, account: true }
  });

  if (!order) return;

  const units = lots * order.contract.lotSize;
  const premium = price * units;
  const fees = calculateFees(price, units);

  await prisma.trade.create({
    data: {
      orderId: order.id,
      contractId: order.contractId,
      side: order.side,
      qty: lots,
      price
    }
  });

  await prisma.order.update({
    where: { id: orderId },
    data: { status: 'FILLED' }
  });

  const existingPosition = await prisma.position.findUnique({
    where: {
      accountId_contractId: {
        accountId: order.accountId,
        contractId: order.contractId
      }
    }
  });

  if (existingPosition) {
    const currentNetLots = existingPosition.netLots;
    const currentAvgPrice = parseFloat(existingPosition.avgPrice.toString());
    const currentValue = currentNetLots * order.contract.lotSize * currentAvgPrice;

    const newLots = order.side === 'BUY' ? lots : -lots;
    const newNetLots = currentNetLots + newLots;

    if (newNetLots === 0) {
      await prisma.position.delete({
        where: { id: existingPosition.id }
      });

      const realizedPnL = (price - currentAvgPrice) * Math.abs(currentNetLots) * order.contract.lotSize;
      await prisma.cashLedger.create({
        data: {
          accountId: order.accountId,
          type: realizedPnL >= 0 ? 'CREDIT' : 'DEBIT',
          amount: Math.abs(realizedPnL),
          reason: 'REALIZED_PNL',
          refId: orderId
        }
      });
    } else {
      const newValue = currentValue + (newLots * order.contract.lotSize * price);
      const newAvgPrice = newValue / (newNetLots * order.contract.lotSize);

      await prisma.position.update({
        where: { id: existingPosition.id },
        data: {
          netLots: newNetLots,
          avgPrice: newAvgPrice
        }
      });
    }
  } else {
    await prisma.position.create({
      data: {
        accountId: order.accountId,
        contractId: order.contractId,
        netLots: order.side === 'BUY' ? lots : -lots,
        avgPrice: price
      }
    });
  }

  await prisma.cashLedger.create({
    data: {
      accountId: order.accountId,
      type: 'DEBIT',
      amount: fees,
      reason: 'TRADING_FEES',
      refId: orderId
    }
  });

  await prisma.cashLedger.create({
    data: {
      accountId: order.accountId,
      type: order.side === 'BUY' ? 'DEBIT' : 'CREDIT',
      amount: premium,
      reason: 'TRADE',
      refId: orderId
    }
  });

  await broadcastPnL(order.accountId);
}

export async function cancelOrder(orderId: string) {
  const order = await prisma.order.findUnique({
    where: { id: orderId }
  });

  if (!order || order.status !== 'OPEN') {
    throw new Error('Cannot cancel order');
  }

  await prisma.order.update({
    where: { id: orderId },
    data: { status: 'CANCELLED' }
  });

  return { success: true };
}
</file>

<file path="backend/src/services/pnl.service.ts">
import { PrismaClient } from '@prisma/client';
import Redis from 'ioredis';

const prisma = new PrismaClient();
const redis = new Redis(process.env.REDIS_URL!);

export interface PositionPnL {
  contractId: bigint;
  tradingSymbol: string;
  netLots: number;
  netUnits: number;
  avgPrice: number;
  ltp: number;
  mtm: number;
}

export interface AccountPnL {
  accountId: string;
  positions: PositionPnL[];
  totalMtm: number;
  realizedPnL: number;
  fees: number;
  netPnL: number;
  capitalUsed: number;
  capitalLeft: number;
}

export async function calculatePositionMTM(
  netLots: number,
  lotSize: number,
  avgPrice: number,
  ltp: number
): Promise<{ units: number; mtm: number }> {
  const units = netLots * lotSize;
  const mtm = units * (ltp - avgPrice);
  return { units, mtm };
}

export async function getAccountPnL(accountId: string): Promise<AccountPnL> {
  const account = await prisma.account.findUnique({
    where: { id: accountId },
    include: {
      positions: {
        include: {
          contract: true
        }
      }
    }
  });

  if (!account) {
    throw new Error('Account not found');
  }

  const positionPnLs: PositionPnL[] = [];
  let totalMtm = 0;

  for (const position of account.positions) {
    const ltp = await redis.get(`ltp:${position.contract.tradingSymbol}`);
    const currentLtp = ltp ? parseFloat(ltp) : parseFloat(position.avgPrice.toString());
    
    const { units, mtm } = await calculatePositionMTM(
      position.netLots,
      position.contract.lotSize,
      parseFloat(position.avgPrice.toString()),
      currentLtp
    );

    positionPnLs.push({
      contractId: position.contractId,
      tradingSymbol: position.contract.tradingSymbol,
      netLots: position.netLots,
      netUnits: units,
      avgPrice: parseFloat(position.avgPrice.toString()),
      ltp: currentLtp,
      mtm
    });

    totalMtm += mtm;
  }

  const ledgerEntries = await prisma.cashLedger.findMany({
    where: { accountId }
  });

  let realizedPnL = 0;
  let fees = 0;
  let capitalUsed = parseFloat(account.baseCapital.toString());

  ledgerEntries.forEach(entry => {
    const amount = parseFloat(entry.amount.toString());
    if (entry.type === 'CREDIT') {
      realizedPnL += amount;
    } else if (entry.type === 'DEBIT') {
      if (entry.reason?.includes('FEE')) {
        fees += amount;
      } else {
        capitalUsed -= amount;
      }
    }
  });

  const netPnL = totalMtm + realizedPnL - fees;
  const capitalLeft = capitalUsed + realizedPnL + totalMtm;

  return {
    accountId,
    positions: positionPnLs,
    totalMtm,
    realizedPnL,
    fees,
    netPnL,
    capitalUsed,
    capitalLeft
  };
}

export async function broadcastPnL(accountId: string): Promise<void> {
  const pnl = await getAccountPnL(accountId);
  await redis.publish(`pnl:${accountId}`, JSON.stringify(pnl));
}
</file>

<file path="backend/src/services/quote.service.ts">
interface Quote {
  ltp: number;
  bid: number;
  ask: number;
  volume: number;
  oi: number;
}

export async function getQuote(symbol: string): Promise<Quote> {
  const basePrice = Math.random() * 1000 + 100;
  
  return {
    ltp: parseFloat(basePrice.toFixed(2)),
    bid: parseFloat((basePrice * 0.98).toFixed(2)),
    ask: parseFloat((basePrice * 1.02).toFixed(2)),
    volume: Math.floor(Math.random() * 100000),
    oi: Math.floor(Math.random() * 1000000),
  };
}
</file>

<file path="backend/src/services/upstox.service.ts">
import axios from 'axios';
import * as fs from 'fs';
import * as path from 'path';

const UPSTOX_BASE_URL = 'https://api.upstox.com/v2';

interface TokenData {
  access_token: string;
  saved_at: string;
}

class UpstoxService {
  private accessToken: string | null = null;
  private tokenFilePath = path.join(__dirname, '../../.upstox-token.json');

  constructor() {
    this.loadToken();
  }

  private loadToken() {
    try {
      if (fs.existsSync(this.tokenFilePath)) {
        const data: TokenData = JSON.parse(fs.readFileSync(this.tokenFilePath, 'utf8'));
        this.accessToken = data.access_token;
        console.log('‚úÖ Upstox token loaded from file');
      }
    } catch (error) {
      console.log('‚ÑπÔ∏è  No saved token found');
    }
  }

  private saveToken(token: string) {
    try {
      const data: TokenData = {
        access_token: token,
        saved_at: new Date().toISOString()
      };
      fs.writeFileSync(this.tokenFilePath, JSON.stringify(data, null, 2));
      console.log('‚úÖ Token saved successfully');
    } catch (error) {
      console.error('‚ùå Error saving token:', error);
    }
  }

  isAuthenticated(): boolean {
    return this.accessToken !== null;
  }

  getLoginUrl(): string {
    const apiKey = process.env.UPSTOX_API_KEY;
    const redirectUri = process.env.UPSTOX_REDIRECT_URI;
    
    if (!apiKey || !redirectUri) {
      throw new Error('UPSTOX_API_KEY or UPSTOX_REDIRECT_URI not configured');
    }

    return `https://api.upstox.com/v2/login/authorization/dialog?response_type=code&client_id=${apiKey}&redirect_uri=${encodeURIComponent(redirectUri)}`;
  }

  async authenticate(authCode: string): Promise<void> {
    try {
      const response = await axios.post(
        `${UPSTOX_BASE_URL}/login/authorization/token`,
        new URLSearchParams({
          code: authCode,
          client_id: process.env.UPSTOX_API_KEY!,
          client_secret: process.env.UPSTOX_API_SECRET!,
          redirect_uri: process.env.UPSTOX_REDIRECT_URI!,
          grant_type: 'authorization_code'
        }),
        {
          headers: {
            'accept': 'application/json',
            'Api-Version': '2.0',
            'Content-Type': 'application/x-www-form-urlencoded'
          }
        }
      );

      this.accessToken = response.data.access_token;
      
      // ‚úÖ FIX: Check that accessToken is not null before saving
      if (this.accessToken) {
        this.saveToken(this.accessToken);
      }
      
      console.log('‚úÖ Upstox authentication successful');
    } catch (error: any) {
      console.error('‚ùå Authentication error:', error.response?.data || error.message);
      throw new Error('Failed to authenticate with Upstox');
    }
  }

  private async makeRequest(endpoint: string, params?: any): Promise<any> {
    if (!this.accessToken) {
      throw new Error('Not authenticated. Please authenticate first via /auth/upstox/login');
    }

    try {
      const response = await axios.get(`${UPSTOX_BASE_URL}${endpoint}`, {
        params,
        headers: {
          'Accept': 'application/json',
          'Api-Version': '2.0',
          'Authorization': `Bearer ${this.accessToken}`
        }
      });

      return response.data;
    } catch (error: any) {
      if (error.response?.status === 401) {
        this.accessToken = null;
        if (fs.existsSync(this.tokenFilePath)) {
          fs.unlinkSync(this.tokenFilePath);
        }
        throw new Error('Token expired. Please re-authenticate via /auth/upstox/login');
      }
      throw error;
    }
  }

  async getMarketQuote(symbols: string[]): Promise<any> {
    const symbolParam = symbols.join(',');
    return this.makeRequest('/market-quote/quotes', { symbol: symbolParam });
  }

  async getLTP(symbols: string[]): Promise<any> {
    const symbolParam = symbols.join(',');
    return this.makeRequest('/market-quote/ltp', { symbol: symbolParam });
  }

  async getOptionChain(instrumentKey: string, expiryDate: string): Promise<any> {
    return this.makeRequest('/option/chain', {
      instrument_key: instrumentKey,
      expiry_date: expiryDate
    });
  }

  async getHistoricalData(
    instrumentKey: string,
    interval: string,
    toDate: string,
    fromDate: string
  ): Promise<any> {
    return this.makeRequest(
      `/historical-candle/${instrumentKey}/${interval}/${toDate}/${fromDate}`
    );
  }
}

export const upstoxService = new UpstoxService();
</file>

<file path="backend/src/utils/helpers.ts">
import { FEES } from '../config/constants';

export function calculateFees(premium: number, qty: number): number {
  const turnover = premium * qty;
  const brokerage = turnover * FEES.brokerage;
  const exchangeFee = turnover * FEES.exchangeTxn;
  const gst = brokerage * FEES.gst;
  const sebi = turnover * FEES.sebi;
  const stamp = turnover * FEES.stampDuty;
  
  return brokerage + exchangeFee + gst + sebi + stamp;
}

export function roundToTick(price: number, tickSize: number = 0.05): number {
  return Math.round(price / tickSize) * tickSize;
}

export function generateTradingSymbol(
  index: string,
  expiry: Date,
  strike: number,
  optionType: 'CE' | 'PE'
): string {
  const year = expiry.getFullYear().toString().slice(-2);
  const months = ['JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC'];
  const month = months[expiry.getMonth()];
  const day = expiry.getDate().toString().padStart(2, '0');
  
  return `${index}${year}${month}${day}${strike}${optionType}`;
}

export function calculateIntrinsicValue(
  optionType: 'CE' | 'PE',
  strike: number,
  underlyingPrice: number
): number {
  if (optionType === 'CE') {
    return Math.max(0, underlyingPrice - strike);
  } else {
    return Math.max(0, strike - underlyingPrice);
  }
}
// backend/src/utils/toSafeJson.ts

export function toSafeJson(obj: any): any {
  // Recursively converts all BigInt values in an object/array to string
  if (Array.isArray(obj)) {
    return obj.map(toSafeJson);
  } else if (obj && typeof obj === 'object') {
    const newObj: any = {};
    for (const key of Object.keys(obj)) {
      if (typeof obj[key] === 'bigint') {
        newObj[key] = obj[key].toString();
      } else if (typeof obj[key] === 'object') {
        newObj[key] = toSafeJson(obj[key]);
      } else {
        newObj[key] = obj[key];
      }
    }
    return newObj;
  }
  return obj;
}
</file>

<file path="backend/src/websocket/ws.server.ts">
import WebSocket from 'ws';

export class MarketDataWebSocket {
  private ws: WebSocket | null = null;
  private reconnectInterval: number = 5000;

  connect(onMessage: (data: any) => void) {
    const wsUrl = `${process.env.WS_API_URL}?apiKey=${process.env.API_KEY}`;
    
    this.ws = new WebSocket(wsUrl);

    this.ws.on('open', () => {
      console.log('WebSocket connected');
      // Subscribe to market data streams
      this.subscribe(['AAPL', 'GOOGL', 'MSFT']);
    });

    this.ws.on('message', (data: string) => {
      const parsedData = JSON.parse(data);
      onMessage(parsedData);
    });

    this.ws.on('error', (error) => {
      console.error('WebSocket error:', error);
    });

    this.ws.on('close', () => {
      console.log('WebSocket closed, reconnecting...');
      setTimeout(() => this.connect(onMessage), this.reconnectInterval);
    });
  }

  subscribe(symbols: string[]) {
    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
      this.ws.send(JSON.stringify({
        action: 'subscribe',
        symbols: symbols
      }));
    }
  }

  disconnect() {
    if (this.ws) {
      this.ws.close();
    }
  }
}
</file>

<file path="backend/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "lib": ["ES2020"],
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "moduleResolution": "node"
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}
</file>

<file path="frontend/.gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
</file>

<file path="frontend/app/admin/page.tsx">
"use client";

import { useState, useEffect } from "react";

interface DashboardData {
  overview: {
    totalUsers: number;
    premiumUsers: number;
    freeUsers: number;
    recentUsers: number;
    activeUsers: number;
    totalCapital: number;
  };
}

interface User {
  id: string;
  username: string;
  phone: string;
  email: string;
  role: string;
  balance: string;
  createdAt: string;
}

interface Settings {
  premiumPrice: number;
  freeCapital: string;
  premiumCapital: string;
  updatedAt: string;
}

interface Announcement {
  id: string;
  title: string;
  message: string;
  targetRole: string;
  type: string;
  isActive: boolean;
  createdAt: string;
  expiresAt: string | null;
}

export default function AdminDashboard() {
  const [authenticated, setAuthenticated] = useState(false);
  const [adminKey, setAdminKey] = useState("");
  const [dashboard, setDashboard] = useState<DashboardData | null>(null);
  const [users, setUsers] = useState<User[]>([]);
  const [loading, setLoading] = useState(false);
  const [activeTab, setActiveTab] = useState<"overview" | "users" | "revenue" | "settings" | "announcements">("overview");
  const [revenue, setRevenue] = useState<any>(null);
  const [settings, setSettings] = useState<Settings | null>(null);
  const [announcements, setAnnouncements] = useState<Announcement[]>([]);
  const [showAnnouncementForm, setShowAnnouncementForm] = useState(false);
  
  // Settings form state
  const [editSettings, setEditSettings] = useState({
    premiumPrice: 99,
    freeCapital: 100000,
    premiumCapital: 1000000,
  });

  // Announcement form state
  const [announcementForm, setAnnouncementForm] = useState({
    title: "",
    message: "",
    targetRole: "all",
    type: "info",
    expiresAt: "",
  });

  async function handleLogin(e: React.FormEvent) {
    e.preventDefault();
    
    if (!adminKey) {
      alert("Please enter admin key");
      return;
    }

    setLoading(true);
    try {
      const apiUrl = process.env.NEXT_PUBLIC_API_URL || "http://localhost:3001";
      const response = await fetch(`${apiUrl}/api/admin/dashboard`, {
        headers: {
          "x-admin-key": adminKey,
        },
      });

      if (response.ok) {
        setAuthenticated(true);
        localStorage.setItem("adminKey", adminKey);
        loadDashboard();
      } else {
        alert("Invalid admin key");
      }
    } catch (error) {
      alert("Failed to authenticate");
    } finally {
      setLoading(false);
    }
  }

  async function loadDashboard() {
    const key = adminKey || localStorage.getItem("adminKey") || "";
    const apiUrl = process.env.NEXT_PUBLIC_API_URL || "http://localhost:3001";
    
    const response = await fetch(`${apiUrl}/api/admin/dashboard`, {
      headers: { "x-admin-key": key },
    });
    
    if (response.ok) {
      const data = await response.json();
      setDashboard(data);
      setAuthenticated(true);
    }
  }

  async function loadUsers() {
    const key = localStorage.getItem("adminKey") || "";
    const apiUrl = process.env.NEXT_PUBLIC_API_URL || "http://localhost:3001";
    
    const response = await fetch(`${apiUrl}/api/admin/users`, {
      headers: { "x-admin-key": key },
    });
    
    if (response.ok) {
      const data = await response.json();
      setUsers(data.users);
    }
  }

  async function loadRevenue() {
    const key = localStorage.getItem("adminKey") || "";
    const apiUrl = process.env.NEXT_PUBLIC_API_URL || "http://localhost:3001";
    
    const response = await fetch(`${apiUrl}/api/admin/revenue`, {
      headers: { "x-admin-key": key },
    });
    
    if (response.ok) {
      const data = await response.json();
      setRevenue(data);
    }
  }

  async function loadSettings() {
    const key = localStorage.getItem("adminKey") || "";
    const apiUrl = process.env.NEXT_PUBLIC_API_URL || "http://localhost:3001";
    
    const response = await fetch(`${apiUrl}/api/admin/settings`, {
      headers: { "x-admin-key": key },
    });
    
    if (response.ok) {
      const data = await response.json();
      setSettings(data);
      setEditSettings({
        premiumPrice: data.premiumPrice,
        freeCapital: Number(data.freeCapital),
        premiumCapital: Number(data.premiumCapital),
      });
    }
  }

  async function loadAnnouncements() {
    const key = localStorage.getItem("adminKey") || "";
    const apiUrl = process.env.NEXT_PUBLIC_API_URL || "http://localhost:3001";
    
    const response = await fetch(`${apiUrl}/api/admin/announcements`, {
      headers: { "x-admin-key": key },
    });
    
    if (response.ok) {
      const data = await response.json();
      setAnnouncements(data.announcements);
    }
  }

  async function handleSaveSettings(e: React.FormEvent) {
    e.preventDefault();
    setLoading(true);
    
    try {
      const key = localStorage.getItem("adminKey") || "";
      const apiUrl = process.env.NEXT_PUBLIC_API_URL || "http://localhost:3001";
      
      const response = await fetch(`${apiUrl}/api/admin/settings`, {
        method: "PATCH",
        headers: {
          "Content-Type": "application/json",
          "x-admin-key": key,
        },
        body: JSON.stringify(editSettings),
      });
      
      if (response.ok) {
        alert("Settings updated successfully!");
        loadSettings();
      } else {
        const data = await response.json();
        alert(data.error || "Failed to update settings");
      }
    } catch (error) {
      alert("Failed to update settings");
    } finally {
      setLoading(false);
    }
  }

  async function handleCreateAnnouncement(e: React.FormEvent) {
    e.preventDefault();
    setLoading(true);
    
    try {
      const key = localStorage.getItem("adminKey") || "";
      const apiUrl = process.env.NEXT_PUBLIC_API_URL || "http://localhost:3001";
      
      const response = await fetch(`${apiUrl}/api/admin/announcements`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "x-admin-key": key,
        },
        body: JSON.stringify(announcementForm),
      });
      
      if (response.ok) {
        alert("Announcement created successfully!");
        setShowAnnouncementForm(false);
        setAnnouncementForm({
          title: "",
          message: "",
          targetRole: "all",
          type: "info",
          expiresAt: "",
        });
        loadAnnouncements();
      } else {
        const data = await response.json();
        alert(data.error || "Failed to create announcement");
      }
    } catch (error) {
      alert("Failed to create announcement");
    } finally {
      setLoading(false);
    }
  }

  async function handleToggleAnnouncement(id: string) {
    const key = localStorage.getItem("adminKey") || "";
    const apiUrl = process.env.NEXT_PUBLIC_API_URL || "http://localhost:3001";
    
    const response = await fetch(`${apiUrl}/api/admin/announcements/${id}/toggle`, {
      method: "PATCH",
      headers: { "x-admin-key": key },
    });
    
    if (response.ok) {
      loadAnnouncements();
    }
  }

  async function handleDeleteAnnouncement(id: string) {
    if (!confirm("Are you sure you want to delete this announcement?")) return;
    
    const key = localStorage.getItem("adminKey") || "";
    const apiUrl = process.env.NEXT_PUBLIC_API_URL || "http://localhost:3001";
    
    const response = await fetch(`${apiUrl}/api/admin/announcements/${id}`, {
      method: "DELETE",
      headers: { "x-admin-key": key },
    });
    
    if (response.ok) {
      alert("Announcement deleted successfully!");
      loadAnnouncements();
    }
  }

  useEffect(() => {
    const key = localStorage.getItem("adminKey");
    if (key) {
      setAdminKey(key);
      loadDashboard();
    }
  }, []);

  useEffect(() => {
    if (authenticated) {
      if (activeTab === "overview") loadDashboard();
      if (activeTab === "users") loadUsers();
      if (activeTab === "revenue") loadRevenue();
      if (activeTab === "settings") loadSettings();
      if (activeTab === "announcements") loadAnnouncements();
    }
  }, [activeTab, authenticated]);

  function handleLogout() {
    localStorage.removeItem("adminKey");
    setAuthenticated(false);
    setAdminKey("");
  }

  // Login Screen
  if (!authenticated) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gradient-to-br from-gray-900 to-gray-800">
        <div className="bg-white rounded-2xl shadow-2xl w-full max-w-md p-8">
          <div className="text-center mb-8">
            <div className="text-5xl mb-4">üîê</div>
            <h1 className="text-3xl font-bold text-gray-800">Admin Panel</h1>
            <p className="text-gray-600 mt-2">PaperBull Dashboard</p>
          </div>

          <form onSubmit={handleLogin} className="space-y-4">
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-2">
                Admin Key
              </label>
              <input
                type="password"
                placeholder="Enter admin key"
                value={adminKey}
                onChange={(e) => setAdminKey(e.target.value)}
                className="w-full px-4 py-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 text-gray-900"
                required
              />
            </div>

            <button
              type="submit"
              disabled={loading}
              className="w-full px-4 py-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 text-gray-900"
            >
              {loading ? "Authenticating..." : "Login"}
            </button>
          </form>
        </div>
      </div>
    );
  }

  // Dashboard
  return (
    <div className="min-h-screen bg-gray-100">
      {/* Header */}
      <header className="bg-white shadow">
        <div className="max-w-7xl mx-auto px-4 py-4 flex justify-between items-center">
          <h1 className="text-2xl font-bold text-gray-800">üìä PaperBull Admin</h1>
          <button
            onClick={handleLogout}
            className="bg-red-600 text-white px-4 py-2 rounded-lg hover:bg-red-700"
          >
            Logout
          </button>
        </div>
      </header>

      {/* Tabs */}
      <div className="bg-white border-b">
        <div className="max-w-7xl mx-auto px-4">
          <div className="flex gap-8">
            {["overview", "users", "revenue", "settings", "announcements"].map((tab) => (
              <button
                key={tab}
                onClick={() => setActiveTab(tab as any)}
                className={`py-4 px-2 border-b-2 font-medium capitalize ${
                  activeTab === tab
                    ? "border-blue-600 text-blue-600"
                    : "border-transparent text-gray-600 hover:text-gray-800"
                }`}
              >
                {tab}
              </button>
            ))}
          </div>
        </div>
      </div>

      {/* Content */}
      <main className="max-w-7xl mx-auto px-4 py-8">
        {/* Overview Tab */}
        {activeTab === "overview" && dashboard && (
          <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
            <div className="bg-white p-6 rounded-lg shadow">
              <h3 className="text-gray-600 text-sm font-medium mb-2">Total Users</h3>
              <p className="text-3xl font-bold text-gray-800">{dashboard.overview.totalUsers}</p>
            </div>
            
            <div className="bg-white p-6 rounded-lg shadow">
              <h3 className="text-gray-600 text-sm font-medium mb-2">Premium Users</h3>
              <p className="text-3xl font-bold text-purple-600">{dashboard.overview.premiumUsers}</p>
            </div>
            
            <div className="bg-white p-6 rounded-lg shadow">
              <h3 className="text-gray-600 text-sm font-medium mb-2">Free Users</h3>
              <p className="text-3xl font-bold text-gray-900">{dashboard.overview.freeUsers}</p>
            </div>
            
            <div className="bg-white p-6 rounded-lg shadow">
              <h3 className="text-gray-600 text-sm font-medium mb-2">Recent Users (7d)</h3>
              <p className="text-3xl font-bold text-green-600">{dashboard.overview.recentUsers}</p>
            </div>
            
            <div className="bg-white p-6 rounded-lg shadow">
              <h3 className="text-gray-600 text-sm font-medium mb-2">Active Users (30d)</h3>
              <p className="text-3xl font-bold text-orange-600">{dashboard.overview.activeUsers}</p>
            </div>
            
            <div className="bg-white p-6 rounded-lg shadow">
              <h3 className="text-gray-600 text-sm font-medium mb-2">Total Capital</h3>
              <p className="text-3xl font-bold text-indigo-600">
                ‚Çπ{(dashboard.overview.totalCapital / 100000).toFixed(1)}L
              </p>
            </div>
          </div>
        )}

        {/* Users Tab */}
        {activeTab === "users" && (
          <div className="bg-white rounded-lg shadow overflow-hidden">
            <table className="w-full">
              <thead className="bg-gray-50">
                <tr>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-900 uppercase">Name</th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-900 uppercase">Phone</th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-900 uppercase">Role</th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-900 uppercase">Balance</th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">Joined</th>
                </tr>
              </thead>
              <tbody className="divide-y divide-gray-900">
                {users.map((user) => (
                  <tr key={user.id} className="hover:bg-gray-50 gray-900">
                    <td className="px-6 py-4 whitespace-nowrap text-black">{user.username}</td>
                    <td className="px-6 py-4 whitespace-nowrap text-black">{user.phone}</td>
                    <td className="px-6 py-4 whitespace-nowrap text-black">
                      <span
                        className={`px-2 py-1 rounded-full text-xs font-semibold ${
                          user.role === "premium"
                            ? "bg-purple-100 text-purple-800"
                            : "bg-blue-100 text-text-black"
                        }`}
                      >
                        {user.role}
                      </span>
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap text-black">‚Çπ{(Number(user.balance) / 100000).toFixed(1)}L</td>
                    <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-900">
                      {new Date(user.createdAt).toLocaleDateString()}
                    </td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        )}

        {/* Revenue Tab */}
        {activeTab === "revenue" && revenue && (
          <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
            <div className="bg-white p-6 rounded-lg shadow">
              <h3 className="text-gray-600 text-sm font-medium mb-2">Premium Subscribers</h3>
              <p className="text-3xl font-bold text-purple-600">{revenue.premiumSubscribers}</p>
            </div>
            
            <div className="bg-white p-6 rounded-lg shadow">
              <h3 className="text-gray-600 text-sm font-medium mb-2">Price Per User</h3>
              <p className="text-3xl font-bold text-gray-800">‚Çπ{revenue.pricePerUser}</p>
            </div>
            
            <div className="bg-white p-6 rounded-lg shadow">
              <h3 className="text-gray-600 text-sm font-medium mb-2">Monthly Revenue</h3>
              <p className="text-3xl font-bold text-green-600">‚Çπ{revenue.monthlyRevenue.toLocaleString()}</p>
            </div>
            
            <div className="bg-white p-6 rounded-lg shadow">
              <h3 className="text-gray-600 text-sm font-medium mb-2">Yearly Revenue (Projected)</h3>
              <p className="text-3xl font-bold text-blue-600">‚Çπ{revenue.yearlyRevenue.toLocaleString()}</p>
            </div>
          </div>
        )}

        {/* Settings Tab */}
        {activeTab === "settings" && settings && (
          <div className="max-w-2xl">
            <div className="bg-white rounded-lg shadow p-6">
              <h2 className="text-2xl font-bold text-gray-800 mb-6">App Settings</h2>
              
              <form onSubmit={handleSaveSettings} className="space-y-6">
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-2">
                    Premium Subscription Price (‚Çπ/month)
                  </label>
                  <input
                    type="number"
                    value={editSettings.premiumPrice}
                    onChange={(e) => setEditSettings({...editSettings, premiumPrice: Number(e.target.value)})}
                    min="0"
                    max="10000"
                    className="w-full px-4 py-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 text-gray-900"
                    required
                  />
                  <p className="text-xs text-gray-500 mt-1">Amount users pay monthly for premium membership</p>
                </div>

                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-2">
                    Free User Virtual Capital (‚Çπ)
                  </label>
                  <input
                    type="number"
                    value={editSettings.freeCapital}
                    onChange={(e) => setEditSettings({...editSettings, freeCapital: Number(e.target.value)})}
                    min="10000"
                    max="10000000"
                    step="10000"
                    className="w-full px-4 py-3 border border-gray-900 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 text-gray-900"
                    required
                  />
                  <p className="text-xs text-gray-500 mt-1">
                    Current: ‚Çπ{(editSettings.freeCapital / 100000).toFixed(1)}L
                  </p>
                </div>

                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-2">
                    Premium User Virtual Capital (‚Çπ)
                  </label>
                  <input
                    type="number"
                    value={editSettings.premiumCapital}
                    onChange={(e) => setEditSettings({...editSettings, premiumCapital: Number(e.target.value)})}
                    min="10000"
                    max="100000000"
                    step="10000"
                    className="w-full px-4 py-3 border border-gray-900 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 text-gray-900"
                    required
                  />
                  <p className="text-xs text-gray-500 mt-1">
                    Current: ‚Çπ{(editSettings.premiumCapital / 100000).toFixed(1)}L
                  </p>
                </div>

                <div className="pt-4 border-t">
                  <p className="text-sm text-gray-600">
                    Last updated: {new Date(settings.updatedAt).toLocaleString()}
                  </p>
                </div>

                <button
                  type="submit"
                  disabled={loading}
                  className="w-full bg-blue-600 text-white py-3 rounded-lg hover:bg-blue-700 disabled:bg-gray-400 font-semibold transition"
                >
                  {loading ? "Saving..." : "Save Settings"}
                </button>
              </form>
            </div>

            <div className="mt-6 bg-yellow-50 border border-yellow-200 rounded-lg p-4">
              <p className="text-sm text-yellow-800">
                <strong>‚ö†Ô∏è Note:</strong> Changing these settings will affect new registrations only. 
                Existing users' capital will not be automatically adjusted.
              </p>
            </div>
          </div>
        )}

        {/* Announcements Tab */}
        {activeTab === "announcements" && (
          <div className="space-y-6">
            <div className="flex justify-between items-center">
              <h2 className="text-2xl font-bold text-gray-800">Announcements</h2>
              <button
                onClick={() => setShowAnnouncementForm(!showAnnouncementForm)}
                className="bg-blue-600 text-white px-6 py-3 rounded-lg hover:bg-blue-700 font-semibold"
              >
                {showAnnouncementForm ? "Cancel" : "+ New Announcement"}
              </button>
            </div>

            {showAnnouncementForm && (
              <div className="bg-white rounded-lg shadow p-6">
                <h3 className="text-lg font-bold text-gray-800 mb-4">Create Announcement</h3>
                <form onSubmit={handleCreateAnnouncement} className="space-y-4">
                  <div>
                    <label className="block text-sm font-medium text-gray-700 mb-2">Title</label>
                    <input
                      type="text"
                      value={announcementForm.title}
                      onChange={(e) => setAnnouncementForm({...announcementForm, title: e.target.value})}
                      className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500"
                      placeholder="Important Update"
                      required
                    />
                  </div>

                  <div>
                    <label className="block text-sm font-medium text-gray-700 mb-2">Message</label>
                    <textarea
                      value={announcementForm.message}
                      onChange={(e) => setAnnouncementForm({...announcementForm, message: e.target.value})}
                      className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500"
                      placeholder="Your message here..."
                      rows={3}
                      required
                    />
                  </div>

                  <div className="grid grid-cols-2 gap-4">
                    <div>
                      <label className="block text-sm font-medium text-gray-700 mb-2">Target Audience</label>
                      <select
                        value={announcementForm.targetRole}
                        onChange={(e) => setAnnouncementForm({...announcementForm, targetRole: e.target.value})}
                        className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500"
                      >
                        <option value="all">All Users</option>
                        <option value="premium">Premium Users Only</option>
                        <option value="free">Free Users Only</option>
                      </select>
                    </div>

                    <div>
                      <label className="block text-sm font-medium text-gray-700 mb-2">Type</label>
                      <select
                        value={announcementForm.type}
                        onChange={(e) => setAnnouncementForm({...announcementForm, type: e.target.value})}
                        className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500"
                      >
                        <option value="info">Info (Blue)</option>
                        <option value="warning">Warning (Yellow)</option>
                        <option value="success">Success (Green)</option>
                      </select>
                    </div>
                  </div>

                  <div>
                    <label className="block text-sm font-medium text-gray-700 mb-2">Expires At (Optional)</label>
                    <input
                      type="datetime-local"
                      value={announcementForm.expiresAt}
                      onChange={(e) => setAnnouncementForm({...announcementForm, expiresAt: e.target.value})}
                      className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500"
                    />
                    <p className="text-xs text-gray-500 mt-1">Leave empty for no expiration</p>
                  </div>

                  <button
                    type="submit"
                    disabled={loading}
                    className="w-full bg-blue-600 text-white py-3 rounded-lg hover:bg-blue-700 disabled:bg-gray-400 font-semibold"
                  >
                    {loading ? "Creating..." : "Create Announcement"}
                  </button>
                </form>
              </div>
            )}

            <div className="space-y-4">
              {announcements.length === 0 && (
                <div className="bg-white rounded-lg shadow p-8 text-center text-gray-500">
                  No announcements yet. Create one to broadcast messages to users!
                </div>
              )}

              {announcements.map((announcement) => (
                <div
                  key={announcement.id}
                  className={`bg-white rounded-lg shadow p-6 ${
                    !announcement.isActive ? "opacity-60" : ""
                  }`}
                >
                  <div className="flex justify-between items-start mb-3">
                    <div className="flex-1">
                      <div className="flex items-center gap-3 mb-2">
                        <h3 className="text-lg font-bold text-gray-800">{announcement.title}</h3>
                        <span
                          className={`px-2 py-1 rounded-full text-xs font-semibold ${
                            announcement.type === "info"
                              ? "bg-blue-100 text-blue-800"
                              : announcement.type === "warning"
                              ? "bg-yellow-100 text-yellow-800"
                              : "bg-green-100 text-green-800"
                          }`}
                        >
                          {announcement.type}
                        </span>
                        <span
                          className={`px-2 py-1 rounded-full text-xs font-semibold ${
                            announcement.targetRole === "all"
                              ? "bg-gray-100 text-gray-800"
                              : announcement.targetRole === "premium"
                              ? "bg-purple-100 text-purple-800"
                              : "bg-blue-100 text-blue-800"
                          }`}
                        >
                          {announcement.targetRole === "all"
                            ? "All Users"
                            : announcement.targetRole === "premium"
                            ? "Premium Only"
                            : "Free Only"}
                        </span>
                      </div>
                      <p className="text-gray-600 mb-2">{announcement.message}</p>
                      <p className="text-xs text-gray-500">
                        Created: {new Date(announcement.createdAt).toLocaleString()}
                        {announcement.expiresAt && (
                          <> ‚Ä¢ Expires: {new Date(announcement.expiresAt).toLocaleString()}</>
                        )}
                      </p>
                    </div>
                  </div>

                  <div className="flex gap-2 pt-3 border-t">
                    <button
                      onClick={() => handleToggleAnnouncement(announcement.id)}
                      className={`px-4 py-2 rounded font-semibold ${
                        announcement.isActive
                          ? "bg-yellow-600 text-white hover:bg-yellow-700"
                          : "bg-green-600 text-white hover:bg-green-700"
                      }`}
                    >
                      {announcement.isActive ? "Disable" : "Enable"}
                    </button>
                    <button
                      onClick={() => handleDeleteAnnouncement(announcement.id)}
                      className="px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700 font-semibold"
                    >
                      Delete
                    </button>
                  </div>
                </div>
              ))}
            </div>
          </div>
        )}
      </main>
    </div>
  );
}
</file>

<file path="frontend/app/globals.css">
@import "tailwindcss";

:root {
  --background: #ffffff;
  --foreground: #171717;
}

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}

body {
  background: var(--background);
  color: var(--foreground);
  font-family: Arial, Helvetica, sans-serif;
}
@keyframes scroll-slow {
  0% {
    transform: translateX(0);
  }
  100% {
    transform: translateX(-50%);
  }
}

.animate-scroll-slow {
  animation: scroll-slow 60s linear infinite;
  display: inline-block;
}

.animate-scroll-slow:hover {
  animation-play-state: paused;
}
@keyframes slide-in {
  from {
    transform: translateX(100%);
    opacity: 0;
  }
  to {
    transform: translateX(0);
    opacity: 1;
  }
}

.animate-slide-in {
  animation: slide-in 0.3s ease-out;
}
</file>

<file path="frontend/app/layout.tsx">
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        {children}
      </body>
    </html>
  );
}
</file>

<file path="frontend/app/login/page.tsx">
"use client";

import { useState } from "react";
import { useRouter } from "next/navigation";

type UserType = "free" | "premium";

export default function LoginPage() {
  const router = useRouter();
  const [step, setStep] = useState<"phone" | "otp" | "register">("phone");
  const [phone, setPhone] = useState("");
  const [otp, setOtp] = useState("");
  const [name, setName] = useState("");
  const [userType, setUserType] = useState<UserType>("free");
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");

  // Step 1: Send OTP
  async function handleSendOTP(e: React.FormEvent) {
    e.preventDefault();
    setError("");
    setLoading(true);

    try {
      const apiUrl = process.env.NEXT_PUBLIC_API_URL || "http://localhost:3001";
      const response = await fetch(`${apiUrl}/api/auth/send-otp`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ phone }),
      });

      const data = await response.json();

      if (!response.ok) {
        if (data.needsRegistration) {
          setStep("register");
        } else {
          throw new Error(data.error || "Failed to send OTP");
        }
      } else {
        setStep("otp");
      }
    } catch (err: any) {
      setError(err.message || "Failed to send OTP");
    } finally {
      setLoading(false);
    }
  }

  // Step 2: Verify OTP and Login
  async function handleVerifyOTP(e: React.FormEvent) {
    e.preventDefault();
    setError("");
    setLoading(true);

    try {
      const apiUrl = process.env.NEXT_PUBLIC_API_URL || "http://localhost:3001";
      const response = await fetch(`${apiUrl}/api/auth/verify-otp`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ phone, otp }),
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.error || "Invalid OTP");
      }

      localStorage.setItem("token", data.token);
      localStorage.setItem("user", JSON.stringify(data.user));
      localStorage.setItem("account", JSON.stringify(data.account));

      router.push("/trading");
    } catch (err: any) {
      setError(err.message || "Invalid OTP");
    } finally {
      setLoading(false);
    }
  }

  // Step 3: Register New User
  async function handleRegister(e: React.FormEvent) {
    e.preventDefault();
    setError("");

    // If premium selected, redirect to payment
    if (userType === "premium") {
      router.push(`/payment?phone=${phone}&name=${encodeURIComponent(name)}`);
      return;
    }

    // For free users, register directly
    setLoading(true);

    try {
      const apiUrl = process.env.NEXT_PUBLIC_API_URL || "http://localhost:3001";
      const response = await fetch(`${apiUrl}/api/auth/register`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ phone, username: name, role: "free" }),
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.error || "Registration failed");
      }

      setStep("phone");
      await handleSendOTP(e);
    } catch (err: any) {
      setError(err.message || "Registration failed");
    } finally {
      setLoading(false);
    }
  }

  return (
    <div className="min-h-screen flex items-center justify-center bg-gradient-to-br from-blue-900 via-indigo-900 to-purple-900">
      <div className="bg-white rounded-2xl shadow-2xl w-full max-w-md p-8">
        <div className="text-center mb-8">
          <h1 className="text-4xl font-bold text-gray-800 mb-2">PaperBull</h1>
          <p className="text-gray-600">Virtual Trading Platform</p>
        </div>

        {error && (
          <div className="mb-4 p-3 bg-red-100 border border-red-400 text-red-700 rounded-lg text-sm">
            {error}
          </div>
        )}

        {/* Step 1: Phone Number */}
        {step === "phone" && (
          <form onSubmit={handleSendOTP} className="space-y-4">
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-2">
                Mobile Number
              </label>
              <div className="flex">
                <span className="inline-flex items-center px-4 bg-gray-100 border border-r-0 border-gray-300 rounded-l-lg text-gray-600">
                  +91
                </span>
                <input
                  type="tel"
                  placeholder="9876543210"
                  value={phone}
                  onChange={(e) => setPhone(e.target.value.replace(/\D/g, "").slice(0, 10))}
                  className="flex-1 px-4 py-3 border border-gray-300 rounded-r-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                  required
                  pattern="[0-9]{10}"
                  maxLength={10}
                />
              </div>
            </div>

            <button
              type="submit"
              disabled={loading || phone.length !== 10}
              className="w-full bg-blue-600 text-white py-3 rounded-lg hover:bg-blue-700 disabled:bg-gray-400 font-semibold transition"
            >
              {loading ? "Sending OTP..." : "Send OTP"}
            </button>
          </form>
        )}

        {/* Step 2: OTP Verification */}
        {step === "otp" && (
          <form onSubmit={handleVerifyOTP} className="space-y-4">
            <div className="text-center mb-4">
              <p className="text-gray-600">OTP sent to</p>
              <p className="font-semibold text-gray-800">+91 {phone}</p>
              <button
                onClick={() => setStep("phone")}
                className="text-blue-600 text-sm hover:underline mt-2"
              >
                Change number
              </button>
            </div>

            <div>
              <label className="block text-sm font-medium text-gray-700 mb-2">
                Enter OTP
              </label>
              <input
                type="text"
                placeholder="000000"
                value={otp}
                onChange={(e) => setOtp(e.target.value.replace(/\D/g, "").slice(0, 6))}
                className="w-full px-4 py-3 border border-gray-300 rounded-lg text-center text-2xl tracking-widest focus:outline-none focus:ring-2 focus:ring-blue-500"
                required
                maxLength={6}
              />
            </div>

            <button
              type="submit"
              disabled={loading || otp.length !== 6}
              className="w-full bg-blue-600 text-white py-3 rounded-lg hover:bg-blue-700 disabled:bg-gray-400 font-semibold transition"
            >
              {loading ? "Verifying..." : "Verify & Login"}
            </button>

            <button
              type="button"
              onClick={handleSendOTP}
              disabled={loading}
              className="w-full text-blue-600 text-sm hover:underline"
            >
              Resend OTP
            </button>
          </form>
        )}

        {/* Step 3: Registration */}
        {step === "register" && (
          <form onSubmit={handleRegister} className="space-y-4">
            <div className="text-center mb-4">
              <p className="text-gray-600">New User Registration</p>
              <p className="font-semibold text-gray-800">+91 {phone}</p>
            </div>

            <div>
              <label className="block text-sm font-medium text-gray-700 mb-2">
                Your Name
              </label>
              <input
                type="text"
                placeholder="John Doe"
                value={name}
                onChange={(e) => setName(e.target.value)}
                className="w-full px-4 py-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                required
              />
            </div>

            <div>
              <label className="block text-sm font-medium text-gray-700 mb-2">
                Account Type
              </label>
              <div className="grid grid-cols-2 gap-3">
                <button
                  type="button"
                  onClick={() => setUserType("free")}
                  className={`p-4 border-2 rounded-lg transition ${
                    userType === "free"
                      ? "border-blue-600 bg-blue-50"
                      : "border-gray-300 hover:border-gray-400"
                  }`}
                >
                  <div className="font-semibold text-gray-800">Free</div>
                  <div className="text-2xl font-bold text-blue-600 mt-1">‚Çπ1L</div>
                  <div className="text-xs text-gray-600 mt-1">Virtual Capital</div>
                </button>

                <button
                  type="button"
                  onClick={() => setUserType("premium")}
                  className={`p-4 border-2 rounded-lg transition ${
                    userType === "premium"
                      ? "border-purple-600 bg-purple-50"
                      : "border-gray-300 hover:border-gray-400"
                  }`}
                >
                  <div className="font-semibold text-gray-800">Premium</div>
                  <div className="text-2xl font-bold text-purple-600 mt-1">‚Çπ10L</div>
                  <div className="text-xs text-gray-600 mt-1">‚Çπ99/month</div>
                </button>
              </div>
            </div>

            <button
              type="submit"
              disabled={loading || !name}
              className="w-full bg-blue-600 text-white py-3 rounded-lg hover:bg-blue-700 disabled:bg-gray-400 font-semibold transition"
            >
              {loading ? "Creating Account..." : userType === "premium" ? "Proceed to Payment" : "Create Account"}
            </button>

            <button
              type="button"
              onClick={() => setStep("phone")}
              className="w-full text-gray-600 text-sm hover:underline"
            >
              ‚Üê Back
            </button>
          </form>
        )}

        <div className="mt-6 p-4 bg-blue-50 border border-blue-200 rounded-lg">
          <p className="text-xs text-blue-800 text-center">
            üîí Secure OTP-based authentication
            <br />
            üí∞ Start trading with virtual money
          </p>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="frontend/app/page.tsx">
"use client";

import { useEffect } from "react";
import { useRouter } from "next/navigation";

export default function Home() {
  const router = useRouter();

  useEffect(() => {
    // Directly redirect to trading page (no login required)
    router.push("/trading");
  }, [router]);

  return (
    <div className="min-h-screen flex items-center justify-center">
      Loading...
    </div>
  );
}
</file>

<file path="frontend/app/payment/page.tsx">
"use client";

import { useState, useEffect } from "react";
import { useRouter, useSearchParams } from "next/navigation";
import Image from "next/image";

export default function PaymentPage() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const [phone, setPhone] = useState("");
  const [name, setName] = useState("");
  const [paymentStatus, setPaymentStatus] = useState<"pending" | "verifying" | "success" | "failed">("pending");
  const [transactionId, setTransactionId] = useState("");
  const [showQR, setShowQR] = useState(true);  // Show QR by default


  // Your UPI ID for receiving payments
  const UPI_ID = "9408306049@hdfcbank"; // Replace with your actual UPI ID
  const AMOUNT = 99;

  useEffect(() => {
    // Get phone and name from URL params
    const phoneParam = searchParams.get("phone");
    const nameParam = searchParams.get("name");
    
    if (phoneParam) setPhone(phoneParam);
    if (nameParam) setName(nameParam);
  }, [searchParams]);

  // Generate UPI payment link
  const generateUPILink = () => {
    const upiLink = `upi://pay?pa=${UPI_ID}&pn=PaperBull&am=${AMOUNT}&cu=INR&tn=Premium Membership`;
    return upiLink;
  };

  // Generate QR code URL (using a QR code API)
  const generateQRCode = () => {
    const upiLink = generateUPILink();
    return `https://api.qrserver.com/v1/create-qr-code/?size=300x300&data=${encodeURIComponent(upiLink)}`;
  };

  // Handle payment verification
  async function handleVerifyPayment(e: React.FormEvent) {
    e.preventDefault();
    
    if (!transactionId || transactionId.length < 12) {
      alert("Please enter a valid transaction ID");
      return;
    }

    setPaymentStatus("verifying");

    try {
      const apiUrl = process.env.NEXT_PUBLIC_API_URL || "http://localhost:3001";
      
      // Send payment verification request
      const response = await fetch(`${apiUrl}/api/payment/verify`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          phone,
          transactionId,
          amount: AMOUNT,
        }),
      });

      const data = await response.json();

      if (response.ok) {
        setPaymentStatus("success");
        
        // Register user as premium after successful payment
        setTimeout(() => {
          registerPremiumUser();
        }, 2000);
      } else {
        throw new Error(data.error || "Payment verification failed");
      }
    } catch (error: any) {
      console.error("Payment verification error:", error);
      setPaymentStatus("failed");
      alert(error.message || "Payment verification failed. Please contact support.");
    }
  }

  // Register user as premium after payment
  async function registerPremiumUser() {
    try {
      const apiUrl = process.env.NEXT_PUBLIC_API_URL || "http://localhost:3001";
      
      const response = await fetch(`${apiUrl}/api/auth/register`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          phone,
          username: name,
          role: "premium",
        }),
      });

      if (response.ok) {
        // Redirect to login page
        router.push(`/login?phone=${phone}&registered=true`);
      }
    } catch (error) {
      console.error("Registration error:", error);
    }
  }

  return (
    <div className="min-h-screen flex items-center justify-center bg-gradient-to-br from-purple-900 via-indigo-900 to-blue-900 p-4">
      <div className="bg-white rounded-2xl shadow-2xl w-full max-w-md p-8">
        {/* Header */}
        <div className="text-center mb-6">
          <div className="text-4xl mb-2">üíé</div>
          <h1 className="text-3xl font-bold text-gray-800">Premium Membership</h1>
          <p className="text-gray-600 mt-2">Unlock ‚Çπ10 Lakh virtual capital</p>
        </div>

        {/* Payment pending */}
        {paymentStatus === "pending" && (
          <div className="space-y-6">
            {/* Amount Box */}
            <div className="bg-gradient-to-r from-purple-500 to-indigo-600 rounded-xl p-6 text-white text-center">
              <p className="text-sm opacity-90">Monthly Subscription</p>
              <p className="text-5xl font-bold mt-2">‚Çπ99</p>
              <p className="text-sm opacity-90 mt-2">per month</p>
            </div>

            {/* Payment Methods */}
            <div className="space-y-4">
              <h3 className="font-semibold text-gray-800 text-center">Choose Payment Method</h3>

              {/* UPI Apps Button */}
              <a
                href={generateUPILink()}
                className="block w-full bg-blue-600 text-white py-4 rounded-lg font-semibold text-center hover:bg-blue-700 transition"
              >
                üì± Pay with UPI Apps
              </a>

              {/* Show QR Code Button */}
              <button
                onClick={() => setShowQR(!showQR)}
                className="w-full border-2 border-blue-600 text-blue-600 py-4 rounded-lg font-semibold hover:bg-blue-50 transition"
              >
                {showQR ? "Hide QR Code" : "üì∑ Scan QR Code"}
              </button>

              {/* QR Code Display */}
              {showQR && (
                <div className="bg-gray-50 p-6 rounded-xl text-center">
                  <img
                    src={generateQRCode()}
                    alt="UPI QR Code"
                    className="mx-auto mb-4"
                    width={250}
                    height={250}
                  />
                  <p className="text-sm text-gray-600">Scan with any UPI app</p>
                  <p className="text-xs text-gray-500 mt-2 font-mono break-all">{UPI_ID}</p>
                </div>
              )}
            </div>

            {/* Transaction ID Input */}
            <form onSubmit={handleVerifyPayment} className="space-y-4 pt-4 border-t">
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-2">
                  Enter Transaction ID / UPI Ref No.
                </label>
                <input
                  type="text"
                  placeholder="e.g., 402912345678"
                  value={transactionId}
                  onChange={(e) => setTransactionId(e.target.value)}
                  className="w-full px-4 py-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-purple-500"
                  required
                  minLength={12}
                />
                <p className="text-xs text-gray-500 mt-1">
                  Enter the 12-digit UTR/Transaction ID from your payment app
                </p>
              </div>

              <button
                type="submit"
                className="w-full bg-green-600 text-white py-3 rounded-lg font-semibold hover:bg-green-700 transition"
              >
                ‚úì Verify Payment
              </button>
            </form>

            {/* Cancel Button */}
            <button
              onClick={() => router.back()}
              className="w-full text-gray-600 text-sm hover:underline"
            >
              ‚Üê Back to Registration
            </button>
          </div>
        )}

        {/* Verifying */}
        {paymentStatus === "verifying" && (
          <div className="text-center py-12">
            <div className="animate-spin rounded-full h-16 w-16 border-b-4 border-purple-600 mx-auto mb-4"></div>
            <p className="text-gray-600 font-medium">Verifying your payment...</p>
            <p className="text-sm text-gray-500 mt-2">This may take a few moments</p>
          </div>
        )}

        {/* Success */}
        {paymentStatus === "success" && (
          <div className="text-center py-12">
            <div className="text-6xl mb-4">‚úì</div>
            <h2 className="text-2xl font-bold text-green-600 mb-2">Payment Successful!</h2>
            <p className="text-gray-600">Your premium account is being activated...</p>
          </div>
        )}

        {/* Failed */}
        {paymentStatus === "failed" && (
          <div className="text-center py-12">
            <div className="text-6xl mb-4">‚úó</div>
            <h2 className="text-2xl font-bold text-red-600 mb-2">Verification Failed</h2>
            <p className="text-gray-600 mb-6">Please check your transaction ID and try again</p>
            <button
              onClick={() => setPaymentStatus("pending")}
              className="bg-blue-600 text-white px-6 py-2 rounded-lg hover:bg-blue-700"
            >
              Try Again
            </button>
          </div>
        )}

        {/* Benefits Box */}
        {paymentStatus === "pending" && (
          <div className="mt-6 p-4 bg-purple-50 border border-purple-200 rounded-lg">
            <p className="text-xs font-semibold text-purple-800 mb-2">‚ú® Premium Benefits:</p>
            <ul className="text-xs text-purple-700 space-y-1">
              <li>‚Ä¢ ‚Çπ10,00,000 virtual capital (10x more)</li>
              <li>‚Ä¢ Unlimited trades per day</li>
              <li>‚Ä¢ Advanced analytics & reports</li>
              <li>‚Ä¢ Priority support</li>
            </ul>
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="frontend/app/trading/page.tsx">
"use client";

import { useState, useEffect } from "react";
import { useRouter } from "next/navigation";
import OptionChain from "../../components/OptionChain";
import Positions from "../../components/Positions";
import AnnouncementBanner from "../../components/AnnouncementBanner";
import { ToastProvider } from "../../components/ToastContainer";

export default function TradingPage() {
  const router = useRouter();
  const [activeTab, setActiveTab] = useState<"chain" | "positions">("chain");
  const [user, setUser] = useState<any>(null);

  useEffect(() => {
    const token = localStorage.getItem("token");
    const userData = localStorage.getItem("user");

    if (!token || !userData) {
      router.push("/login");
      return;
    }

    setUser(JSON.parse(userData));
  }, [router]);

  if (!user) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600"></div>
      </div>
    );
  }

  const capital = user.role === "premium" ? "‚Çπ10,00,000" : "‚Çπ1,00,000";

  return (
    <ToastProvider>
      <div className="min-h-screen flex flex-col bg-gray-900">
        {/* Header */}
        <header className="bg-gradient-to-r from-blue-600 to-indigo-700 text-white px-6 py-4 shadow-lg">
          <div className="flex justify-between items-center">
            <div>
              <h1 className="text-3xl font-bold">PaperBull</h1>
              <p className="text-sm text-blue-100 mt-1">Virtual Trading Platform</p>
            </div>
            <div className="text-right">
              <p className="text-sm text-blue-100">Welcome, {user.username}</p>
              <p className="font-semibold">{capital} Capital</p>
              <button
                onClick={() => {
                  localStorage.clear();
                  router.push("/login");
                }}
                className="mt-2 text-xs bg-white text-blue-600 px-3 py-1 rounded hover:bg-blue-50"
              >
                Logout
              </button>
            </div>
          </div>
        </header>

        {/* Announcement Banner - Positioned here */}
        <div className="bg-gray-900 px-6 pt-4">
          <AnnouncementBanner />
        </div>

        {/* Tabs */}
        <nav className="bg-gray-800 border-b border-gray-700 px-6">
          <div className="flex gap-8">
            <button
              onClick={() => setActiveTab("chain")}
              className={`py-3 px-2 font-medium border-b-2 transition ${
                activeTab === "chain"
                  ? "border-blue-500 text-blue-400"
                  : "border-transparent text-gray-400 hover:text-gray-200"
              }`}
            >
              Option chain
            </button>
            <button
              onClick={() => setActiveTab("positions")}
              className={`py-3 px-2 font-medium border-b-2 transition ${
                activeTab === "positions"
                  ? "border-blue-500 text-blue-400"
                  : "border-transparent text-gray-400 hover:text-gray-200"
              }`}
            >
              Positions
            </button>
          </div>
        </nav>

        {/* Content */}
        <main className="flex-1 overflow-auto">
          {activeTab === "chain" && <OptionChain />}
          {activeTab === "positions" && <Positions />}
        </main>
      </div>
    </ToastProvider>
  );
}
</file>

<file path="frontend/components/AnnouncementBanner.tsx">
"use client";

import { useState, useEffect } from "react";

interface Announcement {
  id: string;
  title: string;
  message: string;
  type: string;
}

export default function AnnouncementBanner() {
  const [announcements, setAnnouncements] = useState<Announcement[]>([]);
  const [dismissed, setDismissed] = useState<Set<string>>(new Set());

  useEffect(() => {
    loadAnnouncements();
    const interval = setInterval(loadAnnouncements, 5 * 60 * 1000); // Every 5 min
    return () => clearInterval(interval);
  }, []);

  async function loadAnnouncements() {
    try {
      const user = JSON.parse(localStorage.getItem("user") || "{}");
      const role = user.role || "free";
      const apiUrl = process.env.NEXT_PUBLIC_API_URL || "http://localhost:3001";
      const response = await fetch(`${apiUrl}/api/public/announcements?role=${role}`);
      if (response.ok) {
        const data = await response.json();
        setAnnouncements(data.announcements);
      }
    } catch (error) {
      console.error("Failed to load announcements:", error);
    }
  }

  function handleDismiss(id: string) {
    setDismissed(new Set(dismissed).add(id));
  }

  // Only show non-dismissed announcements, as popups in bottom-right corner
  const visible = announcements.filter((a) => !dismissed.has(a.id));
  if (visible.length === 0) return null;

  return (
    <div
      className="fixed z-50 right-6 bottom-6 space-y-4"
      style={{ maxWidth: 350, minWidth: 300 }}
    >
      {visible.map((announcement) => (
        <div
          key={announcement.id}
          className={`relative shadow-lg px-5 py-4 rounded-lg border transition-all duration-500 animate-fade-in-down
            ${
              announcement.type === "info"
                ? "bg-blue-100 text-blue-900 border-blue-200"
                : announcement.type === "warning"
                ? "bg-yellow-100 text-yellow-900 border-yellow-300"
                : "bg-green-100 text-green-900 border-green-200"
            }
          `}
        >
          <div className="flex justify-between items-center mb-2">
            <span className="font-semibold">{announcement.title}</span>
            <button
              onClick={() => handleDismiss(announcement.id)}
              className="text-lg font-bold opacity-60 hover:opacity-100 pb-1 px-2"
            >
              √ó
            </button>
          </div>
          <div>{announcement.message}</div>
        </div>
      ))}
      <style jsx global>{`
        @keyframes fade-in-down {
          from {
            opacity: 0;
            transform: translateY(40px);
          }
          to {
            opacity: 1;
            transform: translateY(0px);
          }
        }
        .animate-fade-in-down {
          animation: fade-in-down 0.5s;
        }
      `}</style>
    </div>
  );
}
</file>

<file path="frontend/components/MarketClosedModal.tsx">
"use client";

interface MarketClosedModalProps {
  isOpen: boolean;
  onClose: () => void;
}

export default function MarketClosedModal({ isOpen, onClose }: MarketClosedModalProps) {
  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
      <div className="bg-gray-800 rounded-lg p-6 w-full max-w-md mx-4 border border-gray-700">
        {/* Icon */}
        <div className="flex justify-center mb-4">
          <div className="text-6xl">üîí</div>
        </div>

        {/* Title */}
        <h2 className="text-xl font-bold text-white text-center mb-2">
          Market is Closed
        </h2>

        {/* Message */}
        <p className="text-gray-400 text-center mb-6">
          Trading is only available during market hours: <br />
          <span className="text-white font-semibold">9:15 AM - 3:30 PM IST</span>
          <br />
          <span className="text-sm text-gray-500 mt-2 block">Monday to Friday</span>
        </p>

        {/* Button */}
        <button
          onClick={onClose}
          className="w-full py-3 bg-blue-600 hover:bg-blue-700 text-white rounded font-semibold transition"
        >
          Got it
        </button>
      </div>
    </div>
  );
}
</file>

<file path="frontend/components/MarketTicker.tsx">
'use client';

import { useState, useEffect } from 'react';

interface IndexData {
  name: string;
  value: number;
  change: number;
  changePercent: number;
}

export default function MarketTicker({ darkMode }: { darkMode: boolean }) {
  const [indices, setIndices] = useState<IndexData[]>([
    { name: 'NIFTY 50', value: 25492.30, change: -17.40, changePercent: -0.07 },
    { name: 'SENSEX', value: 84449.90, change: -55.47, changePercent: -0.07 },
    { name: 'NIFTY BANK', value: 55123.75, change: 123.45, changePercent: 0.22 },
    { name: 'FINNIFTY', value: 23850.60, change: -45.20, changePercent: -0.19 },
    { name: 'MIDCAP NIFTY', value: 14567.80, change: 89.30, changePercent: 0.62 },
    { name: 'NIFTY IT', value: 42346.50, change: -120.30, changePercent: -0.28 },
    { name: 'NIFTY PHARMA', value: 22145.90, change: 67.80, changePercent: 0.31 },
    { name: 'NIFTY AUTO', value: 25678.40, change: 145.60, changePercent: 0.57 },
    { name: 'BSE SENSEX', value: 84449.90, change: -55.47, changePercent: -0.07 },
    { name: 'BSE 500', value: 45123.60, change: 234.50, changePercent: 0.52 },
    { name: 'NIFTY SMALLCAP', value: 18234.70, change: -89.20, changePercent: -0.49 },
    { name: 'INDIA VIX', value: 13.45, change: -0.23, changePercent: -1.68 },
  ]);

  useEffect(() => {
    const interval = setInterval(() => {
      setIndices(prev => prev.map(idx => ({
        ...idx,
        value: idx.value + (Math.random() - 0.5) * 10,
        change: idx.change + (Math.random() - 0.5) * 2,
        changePercent: idx.changePercent + (Math.random() - 0.5) * 0.1,
      })));
    }, 3000);

    return () => clearInterval(interval);
  }, []);

  const textClass = darkMode ? 'text-gray-300' : 'text-gray-700';

  return (
    <div className="flex gap-8 px-4">
      {[...indices, ...indices].map((index, idx) => (
        <div key={idx} className="flex items-center gap-3 min-w-fit">
          <span className={`font-semibold ${textClass}`}>{index.name}</span>
          <span className={`font-bold ${index.change >= 0 ? 'text-green-400' : 'text-red-400'}`}>
            {index.value.toFixed(2)}
          </span>
          <span className={`text-sm ${index.change >= 0 ? 'text-green-400' : 'text-red-400'}`}>
            {index.change >= 0 ? '‚ñ≤' : '‚ñº'} {Math.abs(index.change).toFixed(2)} ({index.changePercent >= 0 ? '+' : ''}{index.changePercent.toFixed(2)}%)
          </span>
        </div>
      ))}
    </div>
  );
}
</file>

<file path="frontend/components/OptionChain.tsx">
"use client";

import { useState, useEffect } from "react";
import { isMarketOpen, getMarketStatus } from "../utils/marketStatus";

export default function OptionChain() {
  const [marketStatus, setMarketStatus] = useState({ isOpen: false, message: "" });

  useEffect(() => {
    const status = getMarketStatus();
    setMarketStatus(status);

    const interval = setInterval(() => {
      const newStatus = getMarketStatus();
      setMarketStatus(newStatus);
    }, 60000);

    return () => clearInterval(interval);
  }, []);

  if (!marketStatus.isOpen) {
    return (
      <div className="flex items-center justify-center min-h-[500px] p-6">
        <div className="text-center max-w-md">
          <div className="flex justify-center mb-6">
            <div className="text-8xl">üîí</div>
          </div>

          <h2 className="text-3xl font-bold text-white mb-4">
            Market is Closed
          </h2>

          <p className="text-gray-400 text-lg mb-3">
            Trading is only available during market hours:
          </p>
          
          <div className="bg-gray-800 rounded-lg p-4 mb-4">
            <p className="text-2xl font-bold text-blue-400">
              9:15 AM - 3:30 PM IST
            </p>
            <p className="text-sm text-gray-500 mt-2">Monday to Friday</p>
          </div>

          <div className="mt-6 p-4 bg-gray-800 rounded-lg border border-gray-700">
            <p className="text-sm text-gray-400">Current Status:</p>
            <p className="text-lg font-semibold text-red-400">{marketStatus.message}</p>
          </div>

          <p className="text-sm text-gray-500 mt-6">
            You can view your positions and order history while the market is closed.
          </p>
        </div>
      </div>
    );
  }

  return (
    <div className="p-6">
      <div className="text-center text-gray-400 py-8">
        <p className="text-green-400 font-semibold mb-2">‚úì Market is Open</p>
        <p>Option chain will load here when market is open</p>
      </div>
    </div>
  );
}
</file>

<file path="frontend/components/OrderHistory.tsx">
'use client';

import { useState, useEffect } from 'react';

interface Order {
  id: string;
  symbol: string;
  quantity: number;
  price: number;
  side: 'BUY' | 'SELL';
  type: string;
  status: string;
  timestamp: string;
}

interface GroupedOrders {
  [date: string]: Order[];
}

export default function OrderHistory() {
  const [orders, setOrders] = useState<Order[]>([]);
  const [groupedOrders, setGroupedOrders] = useState<GroupedOrders>({});
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState('');

  useEffect(() => {
    fetchOrders();
    
    // Auto-refresh every 10 seconds
    const interval = setInterval(fetchOrders, 10000);
    
    return () => clearInterval(interval);
  }, []);

  async function fetchOrders() {
    try {
      setLoading(true);
      setError('');

      const apiUrl = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3001';
      
      console.log('Fetching orders from:', `${apiUrl}/api/paper-trading/orders`);
      
      const response = await fetch(`${apiUrl}/api/paper-trading/orders`);
      
      if (!response.ok) {
        throw new Error(`Failed to fetch orders: ${response.status}`);
      }

      const data = await response.json();
      
      console.log('Orders data received:', data);
      
      const ordersList = data.orders || [];
      
      // Sort orders by timestamp (newest first)
      const sortedOrders = ordersList.sort((a: Order, b: Order) => {
        return new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime();
      });
      
      // Group orders by date
      const grouped = sortedOrders.reduce((acc: GroupedOrders, order: Order) => {
        const date = new Date(order.timestamp).toLocaleDateString('en-IN', {
          year: 'numeric',
          month: 'short',
          day: 'numeric'
        });
        
        if (!acc[date]) {
          acc[date] = [];
        }
        
        acc[date].push(order);
        return acc;
      }, {});
      
      setOrders(sortedOrders);
      setGroupedOrders(grouped);

    } catch (err: any) {
      console.error('Error fetching orders:', err);
      setError(err.message || 'Failed to load order history');
    } finally {
      setLoading(false);
    }
  }

  function formatTime(timestamp: string): string {
    return new Date(timestamp).toLocaleTimeString('en-IN', {
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit',
      hour12: true
    });
  }

  function formatDate(timestamp: string): string {
    return new Date(timestamp).toLocaleDateString('en-IN', {
      weekday: 'short',
      year: 'numeric',
      month: 'short',
      day: 'numeric'
    });
  }

  if (loading && orders.length === 0) {
    return (
      <div className="text-center py-8">
        <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-500 mx-auto mb-4"></div>
        <div className="text-gray-400">Loading order history...</div>
      </div>
    );
  }

  return (
    <div className="bg-gray-800 rounded-lg p-6 border border-gray-700">
      <div className="flex justify-between items-center mb-4">
        <div>
          <h2 className="text-xl font-bold">Order History</h2>
          <div className="text-sm text-gray-400 mt-1">
            Total Orders: {orders.length}
          </div>
        </div>
        <button
          onClick={fetchOrders}
          className="px-3 py-1 bg-blue-600 hover:bg-blue-700 text-sm rounded transition"
        >
          üîÑ Refresh
        </button>
      </div>

      {error && (
        <div className="bg-red-900/20 border border-red-700 text-red-300 px-4 py-2 rounded mb-4">
          {error}
        </div>
      )}

      {orders.length === 0 ? (
        <div className="text-center py-12">
          <div className="text-6xl mb-4">üìù</div>
          <div className="text-xl text-gray-400 mb-2">No orders yet</div>
          <div className="text-sm text-gray-500">Your order history will appear here</div>
        </div>
      ) : (
        <div className="space-y-6">
          {Object.entries(groupedOrders).map(([date, dateOrders]) => (
            <div key={date} className="border border-gray-700 rounded-lg overflow-hidden">
              {/* Date Header */}
              <div className="bg-gray-700/50 px-4 py-2 font-semibold text-sm flex justify-between items-center">
                <span>üìÖ {date}</span>
                <span className="text-gray-400">{dateOrders.length} orders</span>
              </div>

              {/* Orders Table */}
              <div className="overflow-x-auto">
                <table className="w-full text-sm">
                  <thead className="bg-gray-900/50">
                    <tr>
                      <th className="p-3 text-left">Time</th>
                      <th className="p-3 text-left">Order ID</th>
                      <th className="p-3 text-left">Symbol</th>
                      <th className="p-3 text-center">Type</th>
                      <th className="p-3 text-right">Qty</th>
                      <th className="p-3 text-right">Price</th>
                      <th className="p-3 text-right">Total</th>
                      <th className="p-3 text-center">Status</th>
                    </tr>
                  </thead>
                  <tbody>
                    {dateOrders.map((order) => {
                      const total = order.quantity * order.price;
                      
                      return (
                        <tr key={order.id} className="border-b border-gray-700/50 hover:bg-gray-700/30">
                          <td className="p-3 text-gray-400">{formatTime(order.timestamp)}</td>
                          <td className="p-3 font-mono text-xs">{order.id}</td>
                          <td className="p-3 font-semibold">{order.symbol}</td>
                          <td className="p-3 text-center">
                            <span className={`px-2 py-1 rounded text-xs font-semibold ${
                              order.side === 'BUY' 
                                ? 'bg-green-900/30 text-green-400' 
                                : 'bg-red-900/30 text-red-400'
                            }`}>
                              {order.side}
                            </span>
                          </td>
                          <td className="p-3 text-right">{order.quantity}</td>
                          <td className="p-3 text-right">‚Çπ{order.price.toFixed(2)}</td>
                          <td className="p-3 text-right font-semibold">‚Çπ{total.toFixed(2)}</td>
                          <td className="p-3 text-center">
                            <span className={`px-2 py-1 rounded text-xs font-semibold ${
                              order.status === 'COMPLETED' 
                                ? 'bg-blue-900/30 text-blue-400' 
                                : order.status === 'PENDING'
                                ? 'bg-yellow-900/30 text-yellow-400'
                                : 'bg-red-900/30 text-red-400'
                            }`}>
                              {order.status}
                            </span>
                          </td>
                        </tr>
                      );
                    })}
                  </tbody>
                </table>
              </div>
            </div>
          ))}
        </div>
      )}
    </div>
  );
}
</file>

<file path="frontend/components/OrderModal.tsx">
'use client';

import { useState, useEffect } from 'react';

export interface OrderDetails {
  side: 'BUY' | 'SELL';
  lots: number;
  orderType: 'MARKET' | 'LIMIT' | 'SL' | 'SL-M';
  limitPrice?: number;
  triggerPrice?: number;
}

interface OrderModalProps {
  isOpen: boolean;
  onClose: () => void;
  onSubmit: (orderDetails: OrderDetails) => void;
  contract: any;
  initialSide: 'BUY' | 'SELL';
}

export default function OrderModal({ isOpen, onClose, onSubmit, contract, initialSide }: OrderModalProps) {
  const [side, setSide] = useState<'BUY' | 'SELL'>(initialSide);
  const [lots, setLots] = useState(1);
  const [orderType, setOrderType] = useState<'MARKET' | 'LIMIT' | 'SL' | 'SL-M'>('MARKET');
  const [limitPrice, setLimitPrice] = useState('');
  const [triggerPrice, setTriggerPrice] = useState('');

  useEffect(() => {
    setSide(initialSide);
  }, [initialSide]);

  useEffect(() => {
    if (contract) {
      setLimitPrice(contract.ltp.toFixed(2));
      setTriggerPrice(contract.ltp.toFixed(2));
    }
  }, [contract]);

  if (!isOpen || !contract) return null;

  function handleSubmit() {
    const orderDetails: OrderDetails = {
      side,
      lots,
      orderType,
      limitPrice: limitPrice ? parseFloat(limitPrice) : undefined,
      triggerPrice: triggerPrice ? parseFloat(triggerPrice) : undefined,
    };

    onSubmit(orderDetails);
  }

  const totalValue = contract.ltp * lots * contract.lotSize;

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
      <div className="bg-gray-800 rounded-lg p-6 w-full max-w-md">
        <div className="flex justify-between items-center mb-4">
          <h2 className="text-xl font-bold text-white">{contract.tradingSymbol}</h2>
          <button onClick={onClose} className="text-gray-400 hover:text-white text-2xl">√ó</button>
        </div>

        <div className="space-y-4">
          {/* Buy/Sell Toggle */}
          <div className="flex gap-2">
            <button
              onClick={() => setSide('BUY')}
              className={`flex-1 py-2 rounded font-medium ${
                side === 'BUY' ? 'bg-green-600 text-white' : 'bg-gray-700 text-gray-300'
              }`}
            >
              BUY
            </button>
            <button
              onClick={() => setSide('SELL')}
              className={`flex-1 py-2 rounded font-medium ${
                side === 'SELL' ? 'bg-red-600 text-white' : 'bg-gray-700 text-gray-300'
              }`}
            >
              SELL
            </button>
          </div>

          {/* Lots */}
          <div>
            <label className="block text-sm text-gray-400 mb-2">Quantity (Lots)</label>
            <input
              type="number"
              value={lots}
              onChange={(e) => setLots(parseInt(e.target.value) || 1)}
              min="1"
              className="w-full px-3 py-2 bg-gray-700 text-white rounded"
            />
            <p className="text-xs text-gray-400 mt-1">
              {lots} lot(s) = {lots * contract.lotSize} qty
            </p>
          </div>

          {/* Order Type */}
          <div>
            <label className="block text-sm text-gray-400 mb-2">Order Type</label>
            <select
              value={orderType}
              onChange={(e) => setOrderType(e.target.value as any)}
              className="w-full px-3 py-2 bg-gray-700 text-white rounded"
            >
              <option value="MARKET">Market</option>
              <option value="LIMIT">Limit</option>
              <option value="SL">Stop Loss</option>
              <option value="SL-M">Stop Loss Market</option>
            </select>
          </div>

          {/* Limit Price */}
          {(orderType === 'LIMIT' || orderType === 'SL') && (
            <div>
              <label className="block text-sm text-gray-400 mb-2">Limit Price</label>
              <input
                type="number"
                value={limitPrice}
                onChange={(e) => setLimitPrice(e.target.value)}
                step="0.05"
                className="w-full px-3 py-2 bg-gray-700 text-white rounded"
              />
            </div>
          )}

          {/* Trigger Price */}
          {(orderType === 'SL' || orderType === 'SL-M') && (
            <div>
              <label className="block text-sm text-gray-400 mb-2">Trigger Price</label>
              <input
                type="number"
                value={triggerPrice}
                onChange={(e) => setTriggerPrice(e.target.value)}
                step="0.05"
                className="w-full px-3 py-2 bg-gray-700 text-white rounded"
              />
            </div>
          )}

          {/* Total Value */}
          <div className="bg-gray-700 p-3 rounded">
            <div className="flex justify-between text-sm">
              <span className="text-gray-400">Total Value</span>
              <span className="text-white font-bold">‚Çπ{totalValue.toFixed(2)}</span>
            </div>
          </div>

          {/* Submit Button */}
          <button
            onClick={handleSubmit}
            className={`w-full py-3 rounded font-bold text-white ${
              side === 'BUY' ? 'bg-green-600 hover:bg-green-700' : 'bg-red-600 hover:bg-red-700'
            }`}
          >
            Place {side} Order
          </button>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="frontend/components/Positions.tsx">
'use client';
import OrderHistory from './OrderHistory';
import { useState, useEffect } from 'react';

interface Position {
  symbol: string;
  quantity: number;
  avgPrice: number;
  currentPrice: number;
  pnl: number;
}

interface PnL {
  realized: number;
  unrealized: number;
  total: number;
}

export default function Positions() {
  const [positions, setPositions] = useState<Position[]>([]);
  const [pnl, setPnl] = useState<PnL>({ realized: 0, unrealized: 0, total: 0 });
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState('');

  useEffect(() => {
    fetchData();
    
    // Auto-refresh every 5 seconds
    const interval = setInterval(fetchData, 5000);
    
    return () => clearInterval(interval);
  }, []);

  async function fetchData() {
    try {
      setLoading(true);
      setError('');

      const apiUrl = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3001';
      
      console.log('Fetching positions from:', `${apiUrl}/api/paper-trading/portfolio`);
      
      // Fetch portfolio data from paper trading API
      const response = await fetch(`${apiUrl}/api/paper-trading/portfolio`);
      
      if (!response.ok) {
        throw new Error(`Failed to fetch portfolio: ${response.status}`);
      }

      const portfolioData = await response.json();
      
      console.log('Portfolio data received:', portfolioData);
      
      // Extract positions and calculate P&L
      const positionsList = portfolioData.positions || [];
      const totalPnL = positionsList.reduce((sum: number, pos: Position) => {
        return sum + (pos.pnl || 0);
      }, 0);
      
      setPositions(positionsList);
      setPnl({
        realized: 0,
        unrealized: totalPnL,
        total: totalPnL
      });

    } catch (err: any) {
      console.error('Error fetching positions:', err);
      setError(err.message || 'Failed to load positions');
    } finally {
      setLoading(false);
    }
  }

  if (loading && positions.length === 0) {
    return (
      <div className="text-center py-8">
        <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-500 mx-auto mb-4"></div>
        <div className="text-gray-400">Loading positions...</div>
      </div>
    );
  }

    return (
    <div className="space-y-6">
      {/* Portfolio Summary */}
      <div className="bg-gray-800 rounded-lg p-6 border border-gray-700">
        <h2 className="text-xl font-bold mb-4">Portfolio Summary</h2>
        <div className="grid grid-cols-3 gap-6">
          <div>
            <div className="text-gray-400 text-sm mb-1">Total Positions</div>
            <div className="text-2xl font-bold">{positions.length}</div>
          </div>
          <div>
            <div className="text-gray-400 text-sm mb-1">Total P&L</div>
            <div className={`text-2xl font-bold ${pnl.total >= 0 ? 'text-green-400' : 'text-red-400'}`}>
              ‚Çπ{pnl.total.toFixed(2)}
            </div>
          </div>
          <div>
            <div className="text-gray-400 text-sm mb-1">Capital Used</div>
            <div className="text-2xl font-bold">
              ‚Çπ{positions.reduce((sum, pos) => sum + (pos.avgPrice * pos.quantity), 0).toFixed(2)}
            </div>
          </div>
        </div>
      </div>

      {/* Open Positions */}
      <div className="bg-gray-800 rounded-lg p-6 border border-gray-700">
        <div className="flex justify-between items-center mb-4">
          <h2 className="text-xl font-bold">Open Positions</h2>
          <button
            onClick={fetchData}
            className="px-3 py-1 bg-blue-600 hover:bg-blue-700 text-sm rounded transition"
          >
            üîÑ Refresh
          </button>
        </div>

        {error && (
          <div className="bg-red-900/20 border border-red-700 text-red-300 px-4 py-2 rounded mb-4">
            {error}
          </div>
        )}

        {positions.length === 0 ? (
          <div className="text-center py-12">
            <div className="text-6xl mb-4">üìä</div>
            <div className="text-xl text-gray-400 mb-2">No open positions</div>
            <div className="text-sm text-gray-500">Place your first order from the Option Chain tab</div>
          </div>
        ) : (
          <div className="overflow-x-auto">
            <table className="w-full text-sm">
              <thead className="bg-gray-900">
                <tr>
                  <th className="p-3 text-left">Symbol</th>
                  <th className="p-3 text-right">Qty</th>
                  <th className="p-3 text-right">Avg Price</th>
                  <th className="p-3 text-right">Current Price</th>
                  <th className="p-3 text-right">P&L</th>
                  <th className="p-3 text-right">P&L %</th>
                  <th className="p-3 text-center">Action</th>
                </tr>
              </thead>
              <tbody>
                {positions.map((position, index) => {
                  const pnlPercent = ((position.currentPrice - position.avgPrice) / position.avgPrice) * 100;
                  
                  return (
                    <tr key={index} className="border-b border-gray-700 hover:bg-gray-700/50">
                      <td className="p-3 font-semibold">{position.symbol}</td>
                      <td className="p-3 text-right">{position.quantity}</td>
                      <td className="p-3 text-right">‚Çπ{position.avgPrice.toFixed(2)}</td>
                      <td className="p-3 text-right">‚Çπ{position.currentPrice.toFixed(2)}</td>
                      <td className={`p-3 text-right font-semibold ${
                        position.pnl >= 0 ? 'text-green-400' : 'text-red-400'
                      }`}>
                        {position.pnl >= 0 ? '+' : ''}‚Çπ{position.pnl.toFixed(2)}
                      </td>
                      <td className={`p-3 text-right font-semibold ${
                        pnlPercent >= 0 ? 'text-green-400' : 'text-red-400'
                      }`}>
                        {pnlPercent >= 0 ? '+' : ''}{pnlPercent.toFixed(2)}%
                      </td>
                      <td className="p-3 text-center">
                        <button
                          onClick={() => handleSquareOff(position)}
                          className="px-3 py-1 bg-red-600 hover:bg-red-700 text-white text-xs rounded transition"
                        >
                          Square Off
                        </button>
                      </td>
                    </tr>
                  );
                })}
              </tbody>
            </table>
          </div>
        )}
      </div>

      {/* Order History */}
      <OrderHistory />
    </div>
  );


  async function handleSquareOff(position: Position) {
    try {
      const apiUrl = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3001';
      
      const response = await fetch(`${apiUrl}/api/paper-trading/order`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          symbol: position.symbol,
          quantity: position.quantity,
          price: position.currentPrice,
          side: 'SELL',
          type: 'MARKET'
        })
      });

      if (!response.ok) {
        throw new Error('Failed to square off position');
      }

      alert(`‚úÖ Position squared off successfully!\nSymbol: ${position.symbol}\nP&L: ‚Çπ${position.pnl.toFixed(2)}`);
      
      // Refresh positions
      fetchData();
      
    } catch (error: any) {
      console.error('Square off error:', error);
      alert(`‚ùå Failed to square off: ${error.message}`);
    }
  }
}
</file>

<file path="frontend/components/Toast.tsx">
'use client';

import { useEffect } from 'react';

interface ToastProps {
  message: string;
  type: 'success' | 'error' | 'info';
  onClose: () => void;
  duration?: number;
}

export default function Toast({ message, type, onClose, duration = 3000 }: ToastProps) {
  useEffect(() => {
    const timer = setTimeout(onClose, duration);
    return () => clearTimeout(timer);
  }, [duration, onClose]);

  const bgColor = type === 'success' ? 'bg-green-600' : type === 'error' ? 'bg-red-600' : 'bg-blue-600';
  const icon = type === 'success' ? '‚úÖ' : type === 'error' ? '‚ùå' : '‚ÑπÔ∏è';

  return (
    <div className={`${bgColor} text-white px-6 py-4 rounded-lg shadow-lg flex items-center gap-3 min-w-[300px] animate-slide-in`}>
      <span className="text-2xl">{icon}</span>
      <div className="flex-1">
        <p className="font-medium">{message}</p>
      </div>
      <button onClick={onClose} className="text-white hover:text-gray-200 text-xl font-bold">
        √ó
      </button>
    </div>
  );
}
</file>

<file path="frontend/components/ToastContainer.tsx">
'use client';

import { createContext, useContext, useState, useCallback, ReactNode } from 'react';
import Toast from './Toast';

interface ToastMessage {
  id: number;
  message: string;
  type: 'success' | 'error' | 'info';
}

interface ToastContextType {
  showToast: (message: string, type: 'success' | 'error' | 'info') => void;
}

const ToastContext = createContext<ToastContextType | undefined>(undefined);

export function useToast() {
  const context = useContext(ToastContext);
  if (!context) {
    throw new Error('useToast must be used within ToastProvider');
  }
  return context;
}

export function ToastProvider({ children }: { children: ReactNode }) {
  const [toasts, setToasts] = useState<ToastMessage[]>([]);

  const showToast = useCallback((message: string, type: 'success' | 'error' | 'info') => {
    const id = Date.now();
    setToasts((prev) => [...prev, { id, message, type }]);
  }, []);

  const removeToast = useCallback((id: number) => {
    setToasts((prev) => prev.filter((toast) => toast.id !== id));
  }, []);

  return (
    <ToastContext.Provider value={{ showToast }}>
      {children}
      <div className="fixed bottom-4 right-4 z-50 flex flex-col gap-2">
        {toasts.map((toast) => (
          <Toast
            key={toast.id}
            message={toast.message}
            type={toast.type}
            onClose={() => removeToast(toast.id)}
          />
        ))}
      </div>
    </ToastContext.Provider>
  );
}
</file>

<file path="frontend/eslint.config.mjs">
import { defineConfig, globalIgnores } from "eslint/config";
import nextVitals from "eslint-config-next/core-web-vitals";
import nextTs from "eslint-config-next/typescript";

const eslintConfig = defineConfig([
  ...nextVitals,
  ...nextTs,
  // Override default ignores of eslint-config-next.
  globalIgnores([
    // Default ignores of eslint-config-next:
    ".next/**",
    "out/**",
    "build/**",
    "next-env.d.ts",
  ]),
]);

export default eslintConfig;
</file>

<file path="frontend/hooks/useWebSocket.ts">
'use client';

import { useEffect, useRef, useState } from 'react';

export function useWebSocket(url: string) {
  const [isConnected, setIsConnected] = useState(false);
  const [lastMessage, setLastMessage] = useState<any>(null);
  const ws = useRef<WebSocket | null>(null);
  const subscribers = useRef<Map<string, Set<(data: any) => void>>>(new Map());
  const reconnectTimeout = useRef<NodeJS.Timeout>();

  useEffect(() => {
    function connect() {
      try {
        ws.current = new WebSocket(url);

        ws.current.onopen = () => {
          console.log('‚úÖ WebSocket connected');
          setIsConnected(true);
        };

        ws.current.onmessage = (event) => {
          try {
            const data = JSON.parse(event.data);
            setLastMessage(data);
            
            if (data.channel) {
              const channelSubs = subscribers.current.get(data.channel);
              if (channelSubs) {
                channelSubs.forEach(callback => callback(data));
              }
            }
          } catch (error) {
            console.warn('Failed to parse WebSocket message:', error);
          }
        };

        ws.current.onclose = () => {
          console.log('WebSocket disconnected, will retry in 3s...');
          setIsConnected(false);
          
          // Auto-reconnect after 3 seconds
          reconnectTimeout.current = setTimeout(() => {
            connect();
          }, 3000);
        };

        ws.current.onerror = () => {
          console.warn('WebSocket connection error (will retry)');
        };
      } catch (error) {
        console.error('Failed to create WebSocket:', error);
      }
    }

    connect();

    return () => {
      if (reconnectTimeout.current) {
        clearTimeout(reconnectTimeout.current);
      }
      ws.current?.close();
    };
  }, [url]);

  const subscribe = (channels: string[], callback: (data: any) => void) => {
    channels.forEach(channel => {
      if (!subscribers.current.has(channel)) {
        subscribers.current.set(channel, new Set());
      }
      subscribers.current.get(channel)!.add(callback);
    });

    if (ws.current?.readyState === WebSocket.OPEN) {
      ws.current.send(JSON.stringify({ type: 'subscribe', channels }));
    }

    return () => {
      channels.forEach(channel => {
        subscribers.current.get(channel)?.delete(callback);
      });
    };
  };

  return { isConnected, lastMessage, subscribe };
}
</file>

<file path="frontend/lib/api.ts">
const API_BASE_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3001';

export const api = {
  // Market Data APIs
  getOptionChain: async (index: string, expiryDate: string) => {
    const response = await fetch(
      `${API_BASE_URL}/api/market-data/option-chain?instrument_key=${index}&expiry_date=${expiryDate}`
    );
    if (!response.ok) {
      throw new Error('Failed to fetch option chain');
    }
    return response.json();
  },

  getLTP: async (symbols: string[]) => {
    const symbolsParam = symbols.join(',');
    const response = await fetch(
      `${API_BASE_URL}/api/market-data/ltp?symbols=${symbolsParam}`
    );
    if (!response.ok) {
      throw new Error('Failed to fetch LTP');
    }
    return response.json();
  },

  getQuote: async (symbols: string[]) => {
    const symbolsParam = symbols.join(',');
    const response = await fetch(
      `${API_BASE_URL}/api/market-data/quote?symbols=${symbolsParam}`
    );
    if (!response.ok) {
      throw new Error('Failed to fetch quote');
    }
    return response.json();
  },

  // Paper Trading APIs
  getPortfolio: async () => {
    const response = await fetch(`${API_BASE_URL}/api/paper-trading/portfolio`);
    if (!response.ok) {
      throw new Error('Failed to fetch portfolio');
    }
    return response.json();
  },

  placeOrder: async (orderData: any) => {
    const response = await fetch(`${API_BASE_URL}/api/paper-trading/order`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(orderData),
    });
    if (!response.ok) {
      throw new Error('Failed to place order');
    }
    return response.json();
  },

  getOrders: async () => {
    const response = await fetch(`${API_BASE_URL}/api/paper-trading/orders`);
    if (!response.ok) {
      throw new Error('Failed to fetch orders');
    }
    return response.json();
  },
};
</file>

<file path="frontend/next.config.ts">
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
  reactCompiler: true,
};

export default nextConfig;
</file>

<file path="frontend/package.json">
{
  "name": "frontend",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --webpack",
    "build": "next build --webpack",
    "start": "next start",
    "lint": "eslint"
  },
  "dependencies": {
    "axios": "^1.13.2",
    "next": "16.0.1",
    "react": "19.2.0",
    "react-dom": "19.2.0"
  },
  "devDependencies": {
    "@tailwindcss/postcss": "^4",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "babel-plugin-react-compiler": "1.0.0",
    "eslint": "^9",
    "eslint-config-next": "16.0.1",
    "tailwindcss": "^4",
    "typescript": "^5"
  }
}
</file>

<file path="frontend/postcss.config.mjs">
const config = {
  plugins: {
    "@tailwindcss/postcss": {},
  },
};

export default config;
</file>

<file path="frontend/public/file.svg">
<svg fill="none" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M14.5 13.5V5.41a1 1 0 0 0-.3-.7L9.8.29A1 1 0 0 0 9.08 0H1.5v13.5A2.5 2.5 0 0 0 4 16h8a2.5 2.5 0 0 0 2.5-2.5m-1.5 0v-7H8v-5H3v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1M9.5 5V2.12L12.38 5zM5.13 5h-.62v1.25h2.12V5zm-.62 3h7.12v1.25H4.5zm.62 3h-.62v1.25h7.12V11z" clip-rule="evenodd" fill="#666" fill-rule="evenodd"/></svg>
</file>

<file path="frontend/public/globe.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g clip-path="url(#a)"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.27 14.1a6.5 6.5 0 0 0 3.67-3.45q-1.24.21-2.7.34-.31 1.83-.97 3.1M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16m.48-1.52a7 7 0 0 1-.96 0H7.5a4 4 0 0 1-.84-1.32q-.38-.89-.63-2.08a40 40 0 0 0 3.92 0q-.25 1.2-.63 2.08a4 4 0 0 1-.84 1.31zm2.94-4.76q1.66-.15 2.95-.43a7 7 0 0 0 0-2.58q-1.3-.27-2.95-.43a18 18 0 0 1 0 3.44m-1.27-3.54a17 17 0 0 1 0 3.64 39 39 0 0 1-4.3 0 17 17 0 0 1 0-3.64 39 39 0 0 1 4.3 0m1.1-1.17q1.45.13 2.69.34a6.5 6.5 0 0 0-3.67-3.44q.65 1.26.98 3.1M8.48 1.5l.01.02q.41.37.84 1.31.38.89.63 2.08a40 40 0 0 0-3.92 0q.25-1.2.63-2.08a4 4 0 0 1 .85-1.32 7 7 0 0 1 .96 0m-2.75.4a6.5 6.5 0 0 0-3.67 3.44 29 29 0 0 1 2.7-.34q.31-1.83.97-3.1M4.58 6.28q-1.66.16-2.95.43a7 7 0 0 0 0 2.58q1.3.27 2.95.43a18 18 0 0 1 0-3.44m.17 4.71q-1.45-.12-2.69-.34a6.5 6.5 0 0 0 3.67 3.44q-.65-1.27-.98-3.1" fill="#666"/></g><defs><clipPath id="a"><path fill="#fff" d="M0 0h16v16H0z"/></clipPath></defs></svg>
</file>

<file path="frontend/public/next.svg">
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>
</file>

<file path="frontend/public/vercel.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1155 1000"><path d="m577.3 0 577.4 1000H0z" fill="#fff"/></svg>
</file>

<file path="frontend/public/window.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 2.5h13v10a1 1 0 0 1-1 1h-11a1 1 0 0 1-1-1zM0 1h16v11.5a2.5 2.5 0 0 1-2.5 2.5h-11A2.5 2.5 0 0 1 0 12.5zm3.75 4.5a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5M7 4.75a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0m1.75.75a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5" fill="#666"/></svg>
</file>

<file path="frontend/README.md">
This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.
</file>

<file path="frontend/src/axios.ts">
import axios from 'axios';

const api = axios.create({
  baseURL: 'http://localhost:3000', // Make sure this matches your backend port
});

export default api;
</file>

<file path="frontend/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": [
      "dom",
      "dom.iterable",
      "esnext"
    ],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "react-jsx",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": [
        "./*"
      ]
    }
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts",
    ".next/dev/types/**/*.ts"
  ],
  "exclude": [
    "node_modules"
  ]
}
</file>

<file path="frontend/utils/marketStatus.ts">
export function isMarketOpen(): boolean {
  const now = new Date();
  const istOffset = 5.5 * 60 * 60 * 1000;
  const istTime = new Date(now.getTime() + istOffset);
  
  const day = istTime.getUTCDay();
  const hours = istTime.getUTCHours();
  const minutes = istTime.getUTCMinutes();
  
  if (day === 0 || day === 6) {
    return false;
  }
  
  const marketStartTime = 9 * 60 + 15;
  const marketEndTime = 15 * 60 + 30;
  const currentTimeInMinutes = hours * 60 + minutes;
  
  return currentTimeInMinutes >= marketStartTime && currentTimeInMinutes <= marketEndTime;
}

export function getMarketStatus(): {
  isOpen: boolean;
  message: string;
} {
  const now = new Date();
  const istOffset = 5.5 * 60 * 60 * 1000;
  const istTime = new Date(now.getTime() + istOffset);
  const day = istTime.getUTCDay();
  const hours = istTime.getUTCHours();
  const minutes = istTime.getUTCMinutes();
  
  if (day === 0 || day === 6) {
    return {
      isOpen: false,
      message: "Market is closed on weekends"
    };
  }
  
  const currentTimeInMinutes = hours * 60 + minutes;
  const marketStartTime = 9 * 60 + 15;
  const marketEndTime = 15 * 60 + 30;
  
  const open = currentTimeInMinutes >= marketStartTime && currentTimeInMinutes <= marketEndTime;
  
  if (!open) {
    if (currentTimeInMinutes < marketStartTime) {
      return {
        isOpen: false,
        message: "Market will open at 9:15 AM IST"
      };
    } else {
      return {
        isOpen: false,
        message: "Market closed at 3:30 PM IST"
      };
    }
  }
  
  return {
    isOpen: true,
    message: "Market is open"
  };
}
</file>

<file path="New folder/Project withou log in.xml">
This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.env.local
backend/.env
backend/.env.local
backend/.upstox-token.json
backend/package.json
backend/prisma/migrations/20251108052839_init/migration.sql
backend/prisma/migrations/20251108150615_add_phone_and_otp/migration.sql
backend/prisma/migrations/migration_lock.toml
backend/prisma/schema.prisma
backend/src/config/constants.ts
backend/src/controllers/auth.controller.ts
backend/src/controllers/market.controller.ts
backend/src/controllers/orders.controller.ts
backend/src/controllers/positions.controller.ts
backend/src/index.ts
backend/src/routes/auth.routes.ts
backend/src/routes/market-data.routes.ts
backend/src/routes/market.routes.ts
backend/src/routes/order.routes.ts
backend/src/routes/paper-trading.routes.ts
backend/src/routes/position.routes.ts
backend/src/seed.ts
backend/src/services/market-data.service.ts
backend/src/services/order.service.ts
backend/src/services/pnl.service.ts
backend/src/services/quote.service.ts
backend/src/services/upstox.service.ts
backend/src/utils/helpers.ts
backend/src/websocket/ws.server.ts
backend/tsconfig.json
frontend/.gitignore
frontend/app/favicon.ico
frontend/app/globals.css
frontend/app/layout.tsx
frontend/app/login/page.tsx
frontend/app/page.tsx
frontend/app/trading/page.tsx
frontend/components/MarketClosedModal.tsx
frontend/components/MarketTicker.tsx
frontend/components/OptionChain.tsx
frontend/components/OrderHistory.tsx
frontend/components/OrderModal.tsx
frontend/components/Positions.tsx
frontend/components/Toast.tsx
frontend/components/ToastContainer.tsx
frontend/eslint.config.mjs
frontend/hooks/useWebSocket.ts
frontend/lib/api.ts
frontend/next.config.ts
frontend/package.json
frontend/postcss.config.mjs
frontend/public/file.svg
frontend/public/globe.svg
frontend/public/next.svg
frontend/public/vercel.svg
frontend/public/window.svg
frontend/README.md
frontend/src/api.ts
frontend/src/axios.ts
frontend/tsconfig.json
frontend/utils/marketStatus.ts
package.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".env.local">
# API Keys
API_KEY=72adba8b-4015-4bdc-8820-90a8b78a11dc
API_SECRET=li111hdepq

# Backend Configuration (if needed)
DATABASE_URL=your_database_connection_string
NEXT_PUBLIC_API_URL=http://localhost:3001
</file>

<file path="backend/.env">
DATABASE_URL="postgresql://postgres:admin@localhost:5432/papertrading?schema=public"
REDIS_URL="redis://localhost:6379"
JWT_SECRET="my-super-secret-key-change-this-in-production"
PORT=4000
NODE_ENV=development
MSG91_AUTH_KEY=your-msg91-auth-key
MSG91_TEMPLATE_ID=your-template-id
JWT_SECRET=your-strong-secret-key
NODE_ENV=development
</file>

<file path="backend/.env.local">
# Server Configuration
PORT=3001
NODE_ENV=development

# Upstox API Credentials
UPSTOX_API_KEY=72adba8b-4015-4bdc-8820-90a8b78a11dc
UPSTOX_API_SECRET=li111hdepq
UPSTOX_REDIRECT_URI=http://localhost:3001/auth/upstox/callback

# This will be generated after login
UPSTOX_ACCESS_TOKEN=

# Frontend URL
NEXT_PUBLIC_API_URL=http://localhost:3001
</file>

<file path="backend/.upstox-token.json">
{
  "access_token": "eyJ0eXAiOiJKV1QiLCJrZXlfaWQiOiJza192MS4wIiwiYWxnIjoiSFMyNTYifQ.eyJzdWIiOiI0TkNYVDUiLCJqdGkiOiI2OTE4MmRmN2JiZjU2ODY3NGZlZTlkMTkiLCJpc011bHRpQ2xpZW50IjpmYWxzZSwiaXNQbHVzUGxhbiI6dHJ1ZSwiaWF0IjoxNzYzMTkyMzExLCJpc3MiOiJ1ZGFwaS1nYXRld2F5LXNlcnZpY2UiLCJleHAiOjE3NjMyNDQwMDB9.i42Lsw-TSa_C8G0bS9YsUpAgTMTY74WNE9ohzsgYV1M",
  "saved_at": "2025-11-15T07:38:29.956Z"
}
</file>

<file path="backend/package.json">
{
  "name": "paper-trading-backend",
  "version": "1.0.0",
  "description": "Paper Trading Backend with Upstox API",
  "main": "dist/index.js",
  "scripts": {
    "dev": "nodemon --exec ts-node src/index.ts",
    "build": "tsc",
    "start": "node dist/index.js",
    "clean": "rm -rf dist"
  },
  "dependencies": {
    "axios": "^1.6.0",
    "cors": "^2.8.5",
    "dotenv": "^16.3.1",
    "express": "^4.18.2"
  },
  "devDependencies": {
    "@types/cors": "^2.8.14",
    "@types/express": "^4.17.18",
    "@types/node": "^20.8.0",
    "nodemon": "^3.0.1",
    "ts-node": "^10.9.1",
    "typescript": "^5.2.2"
  }
}
</file>

<file path="backend/prisma/migrations/20251108052839_init/migration.sql">
-- CreateTable
CREATE TABLE "users" (
    "id" TEXT NOT NULL,
    "email" TEXT NOT NULL,
    "hash" TEXT NOT NULL,
    "role" TEXT NOT NULL DEFAULT 'free',
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "users_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "accounts" (
    "id" TEXT NOT NULL,
    "userId" TEXT NOT NULL,
    "nickname" TEXT NOT NULL DEFAULT 'Default',
    "baseCapital" DECIMAL(14,2) NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "accounts_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "indices" (
    "symbol" TEXT NOT NULL,
    "displayName" TEXT NOT NULL,
    "lotSize" INTEGER NOT NULL,

    CONSTRAINT "indices_pkey" PRIMARY KEY ("symbol")
);

-- CreateTable
CREATE TABLE "option_contracts" (
    "id" BIGSERIAL NOT NULL,
    "indexSymbol" TEXT NOT NULL,
    "expiryDate" DATE NOT NULL,
    "strike" DECIMAL(10,2) NOT NULL,
    "optionType" TEXT NOT NULL,
    "tradingSymbol" TEXT NOT NULL,
    "tickSize" DECIMAL(8,2) NOT NULL DEFAULT 0.05,
    "lotSize" INTEGER NOT NULL,

    CONSTRAINT "option_contracts_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "orders" (
    "id" TEXT NOT NULL,
    "accountId" TEXT NOT NULL,
    "contractId" BIGINT NOT NULL,
    "side" TEXT NOT NULL,
    "qty" INTEGER NOT NULL,
    "orderType" TEXT NOT NULL,
    "limitPrice" DECIMAL(10,2),
    "triggerPrice" DECIMAL(10,2),
    "status" TEXT NOT NULL DEFAULT 'OPEN',
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "orders_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "trades" (
    "id" BIGSERIAL NOT NULL,
    "orderId" TEXT NOT NULL,
    "contractId" BIGINT NOT NULL,
    "side" TEXT NOT NULL,
    "qty" INTEGER NOT NULL,
    "price" DECIMAL(10,2) NOT NULL,
    "tradedAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "trades_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "positions" (
    "id" BIGSERIAL NOT NULL,
    "accountId" TEXT NOT NULL,
    "contractId" BIGINT NOT NULL,
    "netLots" INTEGER NOT NULL,
    "avgPrice" DECIMAL(10,2) NOT NULL,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "positions_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "cash_ledger" (
    "id" BIGSERIAL NOT NULL,
    "accountId" TEXT NOT NULL,
    "type" TEXT NOT NULL,
    "amount" DECIMAL(12,2) NOT NULL,
    "reason" TEXT,
    "refId" TEXT,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "cash_ledger_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "users_email_key" ON "users"("email");

-- CreateIndex
CREATE UNIQUE INDEX "option_contracts_tradingSymbol_key" ON "option_contracts"("tradingSymbol");

-- CreateIndex
CREATE UNIQUE INDEX "positions_accountId_contractId_key" ON "positions"("accountId", "contractId");

-- AddForeignKey
ALTER TABLE "accounts" ADD CONSTRAINT "accounts_userId_fkey" FOREIGN KEY ("userId") REFERENCES "users"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "option_contracts" ADD CONSTRAINT "option_contracts_indexSymbol_fkey" FOREIGN KEY ("indexSymbol") REFERENCES "indices"("symbol") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "orders" ADD CONSTRAINT "orders_accountId_fkey" FOREIGN KEY ("accountId") REFERENCES "accounts"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "orders" ADD CONSTRAINT "orders_contractId_fkey" FOREIGN KEY ("contractId") REFERENCES "option_contracts"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "trades" ADD CONSTRAINT "trades_orderId_fkey" FOREIGN KEY ("orderId") REFERENCES "orders"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "trades" ADD CONSTRAINT "trades_contractId_fkey" FOREIGN KEY ("contractId") REFERENCES "option_contracts"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "positions" ADD CONSTRAINT "positions_accountId_fkey" FOREIGN KEY ("accountId") REFERENCES "accounts"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "positions" ADD CONSTRAINT "positions_contractId_fkey" FOREIGN KEY ("contractId") REFERENCES "option_contracts"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "cash_ledger" ADD CONSTRAINT "cash_ledger_accountId_fkey" FOREIGN KEY ("accountId") REFERENCES "accounts"("id") ON DELETE RESTRICT ON UPDATE CASCADE;
</file>

<file path="backend/prisma/migrations/20251108150615_add_phone_and_otp/migration.sql">
/*
  Warnings:

  - The primary key for the `accounts` table will be changed. If it partially fails, the table could be left without primary key constraint.
  - You are about to drop the column `baseCapital` on the `accounts` table. All the data in the column will be lost.
  - You are about to drop the column `nickname` on the `accounts` table. All the data in the column will be lost.
  - The `id` column on the `accounts` table would be dropped and recreated. This will lead to data loss if there is data in the column.
  - The primary key for the `indices` table will be changed. If it partially fails, the table could be left without primary key constraint.
  - The primary key for the `orders` table will be changed. If it partially fails, the table could be left without primary key constraint.
  - The `id` column on the `orders` table would be dropped and recreated. This will lead to data loss if there is data in the column.
  - You are about to drop the column `netLots` on the `positions` table. All the data in the column will be lost.
  - You are about to drop the column `tradedAt` on the `trades` table. All the data in the column will be lost.
  - The primary key for the `users` table will be changed. If it partially fails, the table could be left without primary key constraint.
  - You are about to drop the column `hash` on the `users` table. All the data in the column will be lost.
  - The `id` column on the `users` table would be dropped and recreated. This will lead to data loss if there is data in the column.
  - You are about to drop the `cash_ledger` table. If the table is not empty, all the data it contains will be lost.
  - A unique constraint covering the columns `[symbol]` on the table `indices` will be added. If there are existing duplicate values, this will fail.
  - A unique constraint covering the columns `[phone]` on the table `users` will be added. If there are existing duplicate values, this will fail.
  - A unique constraint covering the columns `[username]` on the table `users` will be added. If there are existing duplicate values, this will fail.
  - Added the required column `balance` to the `accounts` table without a default value. This is not possible if the table is not empty.
  - Added the required column `updatedAt` to the `accounts` table without a default value. This is not possible if the table is not empty.
  - Changed the type of `userId` on the `accounts` table. No cast exists, the column would be dropped and recreated, which cannot be done if there is data, since the column is required.
  - Added the required column `updatedAt` to the `indices` table without a default value. This is not possible if the table is not empty.
  - Added the required column `updatedAt` to the `option_contracts` table without a default value. This is not possible if the table is not empty.
  - Added the required column `updatedAt` to the `orders` table without a default value. This is not possible if the table is not empty.
  - Changed the type of `accountId` on the `orders` table. No cast exists, the column would be dropped and recreated, which cannot be done if there is data, since the column is required.
  - Added the required column `netQty` to the `positions` table without a default value. This is not possible if the table is not empty.
  - Changed the type of `accountId` on the `positions` table. No cast exists, the column would be dropped and recreated, which cannot be done if there is data, since the column is required.
  - Added the required column `accountId` to the `trades` table without a default value. This is not possible if the table is not empty.
  - Changed the type of `orderId` on the `trades` table. No cast exists, the column would be dropped and recreated, which cannot be done if there is data, since the column is required.
  - Added the required column `phone` to the `users` table without a default value. This is not possible if the table is not empty.
  - Added the required column `updatedAt` to the `users` table without a default value. This is not possible if the table is not empty.
  - Added the required column `username` to the `users` table without a default value. This is not possible if the table is not empty.

*/
-- DropForeignKey
ALTER TABLE "accounts" DROP CONSTRAINT "accounts_userId_fkey";

-- DropForeignKey
ALTER TABLE "cash_ledger" DROP CONSTRAINT "cash_ledger_accountId_fkey";

-- DropForeignKey
ALTER TABLE "option_contracts" DROP CONSTRAINT "option_contracts_indexSymbol_fkey";

-- DropForeignKey
ALTER TABLE "orders" DROP CONSTRAINT "orders_accountId_fkey";

-- DropForeignKey
ALTER TABLE "positions" DROP CONSTRAINT "positions_accountId_fkey";

-- DropForeignKey
ALTER TABLE "trades" DROP CONSTRAINT "trades_orderId_fkey";

-- AlterTable
ALTER TABLE "accounts" DROP CONSTRAINT "accounts_pkey",
DROP COLUMN "baseCapital",
DROP COLUMN "nickname",
ADD COLUMN     "balance" DECIMAL(20,2) NOT NULL,
ADD COLUMN     "updatedAt" TIMESTAMP(3) NOT NULL,
DROP COLUMN "id",
ADD COLUMN     "id" BIGSERIAL NOT NULL,
DROP COLUMN "userId",
ADD COLUMN     "userId" BIGINT NOT NULL,
ADD CONSTRAINT "accounts_pkey" PRIMARY KEY ("id");

-- AlterTable
ALTER TABLE "indices" DROP CONSTRAINT "indices_pkey",
ADD COLUMN     "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
ADD COLUMN     "id" BIGSERIAL NOT NULL,
ADD COLUMN     "updatedAt" TIMESTAMP(3) NOT NULL,
ADD CONSTRAINT "indices_pkey" PRIMARY KEY ("id");

-- AlterTable
ALTER TABLE "option_contracts" ADD COLUMN     "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
ADD COLUMN     "updatedAt" TIMESTAMP(3) NOT NULL,
ALTER COLUMN "expiryDate" SET DATA TYPE TIMESTAMP(3),
ALTER COLUMN "tickSize" DROP NOT NULL,
ALTER COLUMN "tickSize" DROP DEFAULT,
ALTER COLUMN "tickSize" SET DATA TYPE DECIMAL(10,2);

-- AlterTable
ALTER TABLE "orders" DROP CONSTRAINT "orders_pkey",
ADD COLUMN     "updatedAt" TIMESTAMP(3) NOT NULL,
DROP COLUMN "id",
ADD COLUMN     "id" BIGSERIAL NOT NULL,
DROP COLUMN "accountId",
ADD COLUMN     "accountId" BIGINT NOT NULL,
ALTER COLUMN "limitPrice" SET DATA TYPE DECIMAL(20,2),
ALTER COLUMN "triggerPrice" SET DATA TYPE DECIMAL(20,2),
ALTER COLUMN "status" SET DEFAULT 'PENDING',
ADD CONSTRAINT "orders_pkey" PRIMARY KEY ("id");

-- AlterTable
ALTER TABLE "positions" DROP COLUMN "netLots",
ADD COLUMN     "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
ADD COLUMN     "netQty" INTEGER NOT NULL,
ADD COLUMN     "realizedPnL" DECIMAL(20,2) NOT NULL DEFAULT 0,
DROP COLUMN "accountId",
ADD COLUMN     "accountId" BIGINT NOT NULL,
ALTER COLUMN "avgPrice" SET DATA TYPE DECIMAL(20,2);

-- AlterTable
ALTER TABLE "trades" DROP COLUMN "tradedAt",
ADD COLUMN     "accountId" BIGINT NOT NULL,
ADD COLUMN     "executedAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
ADD COLUMN     "fees" DECIMAL(20,2) NOT NULL DEFAULT 0,
DROP COLUMN "orderId",
ADD COLUMN     "orderId" BIGINT NOT NULL,
ALTER COLUMN "price" SET DATA TYPE DECIMAL(20,2);

-- AlterTable
ALTER TABLE "users" DROP CONSTRAINT "users_pkey",
DROP COLUMN "hash",
ADD COLUMN     "passwordHash" TEXT,
ADD COLUMN     "phone" TEXT NOT NULL,
ADD COLUMN     "updatedAt" TIMESTAMP(3) NOT NULL,
ADD COLUMN     "username" TEXT NOT NULL,
DROP COLUMN "id",
ADD COLUMN     "id" BIGSERIAL NOT NULL,
ADD CONSTRAINT "users_pkey" PRIMARY KEY ("id");

-- DropTable
DROP TABLE "cash_ledger";

-- CreateTable
CREATE TABLE "otps" (
    "id" BIGSERIAL NOT NULL,
    "phone" TEXT NOT NULL,
    "otp" TEXT NOT NULL,
    "expiresAt" TIMESTAMP(3) NOT NULL,
    "verified" BOOLEAN NOT NULL DEFAULT false,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "otps_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE INDEX "otps_phone_idx" ON "otps"("phone");

-- CreateIndex
CREATE UNIQUE INDEX "indices_symbol_key" ON "indices"("symbol");

-- CreateIndex
CREATE UNIQUE INDEX "positions_accountId_contractId_key" ON "positions"("accountId", "contractId");

-- CreateIndex
CREATE UNIQUE INDEX "users_phone_key" ON "users"("phone");

-- CreateIndex
CREATE UNIQUE INDEX "users_username_key" ON "users"("username");

-- AddForeignKey
ALTER TABLE "accounts" ADD CONSTRAINT "accounts_userId_fkey" FOREIGN KEY ("userId") REFERENCES "users"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "orders" ADD CONSTRAINT "orders_accountId_fkey" FOREIGN KEY ("accountId") REFERENCES "accounts"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "trades" ADD CONSTRAINT "trades_orderId_fkey" FOREIGN KEY ("orderId") REFERENCES "orders"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "trades" ADD CONSTRAINT "trades_accountId_fkey" FOREIGN KEY ("accountId") REFERENCES "accounts"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "positions" ADD CONSTRAINT "positions_accountId_fkey" FOREIGN KEY ("accountId") REFERENCES "accounts"("id") ON DELETE RESTRICT ON UPDATE CASCADE;
</file>

<file path="backend/prisma/migrations/migration_lock.toml">
# Please do not edit this file manually
# It should be added in your version-control system (i.e. Git)
provider = "postgresql"
</file>

<file path="backend/prisma/schema.prisma">
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id              BigInt    @id @default(autoincrement())
  email           String    @unique
  phone           String    @unique
  username        String    @unique
  passwordHash    String?
  role            String    @default("free") // 'free' or 'premium'
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  
  accounts        Account[]
  
  @@map("users")
}

model OTP {
  id              BigInt    @id @default(autoincrement())
  phone           String
  otp             String
  expiresAt       DateTime
  verified        Boolean   @default(false)
  createdAt       DateTime  @default(now())
  
  @@index([phone])
  @@map("otps")
}

model Account {
  id              BigInt    @id @default(autoincrement())
  userId          BigInt
  balance         Decimal   @default(100000)
  createdAt       DateTime  @default(now())
  
  user            User      @relation(fields: [userId], references: [id])
  orders          Order[]
  positions       Position[]
  
  @@map("accounts")
}

model Index {
  id              BigInt    @id @default(autoincrement())
  symbol          String    @unique
  displayName     String
  lotSize         Int
  
  @@map("indices")
}

model OptionContract {
  id              BigInt    @id @default(autoincrement())
  tradingSymbol   String    @unique
  indexSymbol     String
  strike          Decimal
  optionType      String    // 'CE' or 'PE'
  expiryDate      String
  lotSize         Int
  
  positions       Position[]
  trades          Trade[]
  
  @@map("option_contracts")
}

model Order {
  id              BigInt    @id @default(autoincrement())
  accountId       BigInt
  tradingSymbol   String
  side            String    // 'BUY' or 'SELL'
  qty             Int
  orderType       String    // 'MARKET', 'LIMIT', 'SL', 'SL-M'
  price           Decimal?
  triggerPrice    Decimal?
  status          String    // 'PENDING', 'EXECUTED', 'CANCELLED'
  filledQty       Int       @default(0)
  avgPrice        Decimal   @default(0)
  createdAt       DateTime  @default(now())
  
  account         Account?  @relation(fields: [accountId], references: [id])
  trades          Trade[]
  
  @@map("orders")
}

model Trade {
  id              BigInt    @id @default(autoincrement())
  orderId         BigInt
  contractId      BigInt
  qty             Int
  price           Decimal
  createdAt       DateTime  @default(now())
  
  order           Order     @relation(fields: [orderId], references: [id])
  contract        OptionContract @relation(fields: [contractId], references: [id])
  
  @@map("trades")
}

model Position {
  id              BigInt    @id @default(autoincrement())
  accountId       BigInt
  contractId      BigInt
  qty             Int       // Positive for long, negative for short
  avgPrice        Decimal
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  
  account         Account   @relation(fields: [accountId], references: [id])
  contract        OptionContract @relation(fields: [contractId], references: [id])
  
  @@unique([accountId, contractId])
  @@map("positions")
}
</file>

<file path="backend/src/config/constants.ts">
export const INDICES = [
  { symbol: 'NIFTY', displayName: 'NIFTY 50', lotSize: 75 },
  { symbol: 'BANKNIFTY', displayName: 'NIFTY BANK', lotSize: 35 },
  { symbol: 'FINNIFTY', displayName: 'FINNIFTY', lotSize: 65 },
  { symbol: 'MIDCPNIFTY', displayName: 'MIDCAP NIFTY', lotSize: 140 }
];

export const FEES = {
  brokerage: 0.0003,
  exchangeTxn: 0.0005,
  gst: 0.18,
  sebi: 0.000001,
  stampDuty: 0.00003
};

export const CAPITAL = {
  free: 100000,
  premium: 1000000
};

export const TICK_SIZE = 0.05;
</file>

<file path="backend/src/controllers/auth.controller.ts">
import { Router, Request, Response } from 'express';
import { PrismaClient } from '@prisma/client';
import bcrypt from 'bcryptjs';
import jwt from 'jsonwebtoken';
import { CAPITAL } from '../config/constants';

const router = Router();
const prisma = new PrismaClient();

router.post('/register', async (req: Request, res: Response) => {
  try {
    const { email, password } = req.body;

    const existing = await prisma.user.findUnique({ where: { email } });
    if (existing) {
      return res.status(400).json({ error: 'Email already registered' });
    }

    const hash = await bcrypt.hash(password, 10);
    const user = await prisma.user.create({
      data: {
        email,
        hash,
        role: 'free'
      }
    });

    const account = await prisma.account.create({
      data: {
        userId: user.id,
        nickname: 'Default',
        baseCapital: CAPITAL.free
      }
    });

    const token = jwt.sign({ userId: user.id }, process.env.JWT_SECRET!, { expiresIn: '7d' });

    res.json({ 
      token, 
      user: { id: user.id, email: user.email, role: user.role },
      account: { id: account.id, capital: CAPITAL.free }
    });
  } catch (error) {
    console.error('Registration error:', error);
    res.status(500).json({ error: 'Registration failed' });
  }
});

router.post('/login', async (req: Request, res: Response) => {
  try {
    const { email, password } = req.body;

    const user = await prisma.user.findUnique({ 
      where: { email },
      include: { accounts: true }
    });
    
    if (!user) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }

    const valid = await bcrypt.compare(password, user.hash);
    if (!valid) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }

    const token = jwt.sign({ userId: user.id }, process.env.JWT_SECRET!, { expiresIn: '7d' });

    res.json({ 
      token, 
      user: { id: user.id, email: user.email, role: user.role },
      account: user.accounts[0] ? { id: user.accounts[0].id, capital: user.accounts[0].baseCapital } : null
    });
  } catch (error) {
    console.error('Login error:', error);
    res.status(500).json({ error: 'Login failed' });
  }
});

export default router;
</file>

<file path="backend/src/controllers/market.controller.ts">
import { Router, Response } from 'express';
import { PrismaClient } from '@prisma/client';
import { AuthRequest, authenticateToken } from '../middleware/auth.middleware';
import { getQuote } from '../services/quote.service';

const router = Router();
const prisma = new PrismaClient();

router.get('/indices', authenticateToken, async (req: AuthRequest, res: Response) => {
  try {
    const indices = await prisma.index.findMany({
      orderBy: { symbol: 'asc' }
    });
    res.json(indices);
  } catch (error) {
    console.error('Fetch indices error:', error);
    res.status(500).json({ error: 'Failed to fetch indices' });
  }
});

router.get('/option-chain', authenticateToken, async (req: AuthRequest, res: Response) => {
  try {
    const { index, expiry } = req.query;

    if (!index) {
      return res.status(400).json({ error: 'Index required' });
    }

    let query: any = {
      indexSymbol: index as string
    };

    if (expiry) {
      query.expiryDate = new Date(expiry as string);
    }

    const contracts = await prisma.optionContract.findMany({
      where: query,
      orderBy: [
        { expiryDate: 'asc' },
        { strike: 'asc' }
      ],
      take: 100
    });

    if (contracts.length === 0) {
      return res.json({ chain: [], message: 'No contracts found. Please run seed script.' });
    }

    const enriched = await Promise.all(
      contracts.map(async (contract) => {
        const quote = await getQuote(contract.tradingSymbol);
        return {
          id: contract.id.toString(),
          tradingSymbol: contract.tradingSymbol,
          strike: parseFloat(contract.strike.toString()),
          optionType: contract.optionType,
          expiryDate: contract.expiryDate,
          lotSize: contract.lotSize,
          ltp: quote?.ltp || 0,
          bid: quote?.bid || 0,
          ask: quote?.ask || 0,
          volume: quote?.volume || 0,
          oi: quote?.oi || 0
        };
      })
    );

    const grouped: any = {};
    enriched.forEach((contract) => {
      const strike = contract.strike.toString();
      if (!grouped[strike]) {
        grouped[strike] = { strike: contract.strike };
      }
      grouped[strike][contract.optionType] = contract;
    });

    res.json({
      chain: Object.values(grouped),
      expiry: contracts[0]?.expiryDate || null
    });
  } catch (error) {
    console.error('Fetch option chain error:', error);
    res.status(500).json({ error: 'Failed to fetch option chain' });
  }
});

export default router;
</file>

<file path="backend/src/controllers/orders.controller.ts">
import { Router, Response } from 'express';
import { PrismaClient } from '@prisma/client';
import { AuthRequest, authenticateToken } from '../middleware/auth.middleware';
import { placeOrder, cancelOrder } from '../services/order.service';

const router = Router();
const prisma = new PrismaClient();

router.post('/', authenticateToken, async (req: AuthRequest, res: Response) => {
  try {
    const { accountId, tradingSymbol, side, lots, orderType, limitPrice, triggerPrice } = req.body;

    if (!accountId || !tradingSymbol || !side || !lots) {
      return res.status(400).json({ error: 'Missing required fields' });
    }

    const order = await placeOrder({
      accountId,
      tradingSymbol,
      side: side.toUpperCase(),
      lots: parseInt(lots),
      orderType: orderType?.toUpperCase() || 'MARKET',
      limitPrice: limitPrice ? parseFloat(limitPrice) : undefined,
      triggerPrice: triggerPrice ? parseFloat(triggerPrice) : undefined
    });

    res.json({ 
      success: true, 
      order: {
        id: order.id,
        status: order.status,
        side: order.side,
        qty: order.qty
      }
    });
  } catch (error: any) {
    console.error('Place order error:', error);
    res.status(400).json({ error: error.message || 'Failed to place order' });
  }
});

router.get('/', authenticateToken, async (req: AuthRequest, res: Response) => {
  try {
    const { accountId } = req.query;
    
    if (!accountId) {
      return res.status(400).json({ error: 'Account ID required' });
    }

    const orders = await prisma.order.findMany({
      where: { accountId: accountId as string },
      include: { 
        contract: true,
        trades: true
      },
      orderBy: { createdAt: 'desc' },
      take: 50
    });

    const formattedOrders = orders.map(order => ({
      id: order.id,
      tradingSymbol: order.contract.tradingSymbol,
      side: order.side,
      qty: order.qty,
      orderType: order.orderType,
      status: order.status,
      limitPrice: order.limitPrice ? parseFloat(order.limitPrice.toString()) : null,
      createdAt: order.createdAt,
      fills: order.trades.map(trade => ({
        qty: trade.qty,
        price: parseFloat(trade.price.toString()),
        time: trade.tradedAt
      }))
    }));

    res.json(formattedOrders);
  } catch (error) {
    console.error('Fetch orders error:', error);
    res.status(500).json({ error: 'Failed to fetch orders' });
  }
});

router.post('/:id/cancel', authenticateToken, async (req: AuthRequest, res: Response) => {
  try {
    const result = await cancelOrder(req.params.id);
    res.json(result);
  } catch (error: any) {
    console.error('Cancel order error:', error);
    res.status(400).json({ error: error.message || 'Failed to cancel order' });
  }
});

export default router;
</file>

<file path="backend/src/controllers/positions.controller.ts">
import { Router, Response } from 'express';
import { PrismaClient } from '@prisma/client';
import { AuthRequest, authenticateToken } from '../middleware/auth.middleware';
import { getAccountPnL } from '../services/pnl.service';

const router = Router();
const prisma = new PrismaClient();

router.get('/', authenticateToken, async (req: AuthRequest, res: Response) => {
  try {
    const { accountId } = req.query;
    
    if (!accountId) {
      return res.status(400).json({ error: 'Account ID required' });
    }

    const positions = await prisma.position.findMany({
      where: { accountId: accountId as string },
      include: { contract: true }
    });

    const formattedPositions = positions.map(pos => ({
      id: pos.id.toString(),
      tradingSymbol: pos.contract.tradingSymbol,
      optionType: pos.contract.optionType,
      strike: parseFloat(pos.contract.strike.toString()),
      netLots: pos.netLots,
      avgPrice: parseFloat(pos.avgPrice.toString()),
      lotSize: pos.contract.lotSize
    }));

    res.json(formattedPositions);
  } catch (error) {
    console.error('Fetch positions error:', error);
    res.status(500).json({ error: 'Failed to fetch positions' });
  }
});

router.get('/pnl', authenticateToken, async (req: AuthRequest, res: Response) => {
  try {
    const { accountId } = req.query;
    
    if (!accountId) {
      return res.status(400).json({ error: 'Account ID required' });
    }

    const pnl = await getAccountPnL(accountId as string);
    
    const formatted = {
      ...pnl,
      positions: pnl.positions.map(p => ({
        ...p,
        contractId: p.contractId.toString()
      }))
    };

    res.json(formatted);
  } catch (error: any) {
    console.error('Fetch PnL error:', error);
    res.status(500).json({ error: error.message || 'Failed to fetch P&L' });
  }
});

export default router;
</file>

<file path="backend/src/index.ts">
import dotenv from 'dotenv';
import path from 'path';

// Load environment variables FIRST
dotenv.config({ path: path.join(__dirname, '../.env.local') });

import express, { Application, Request, Response } from 'express';
import cors from 'cors';

// Import routes
import authRoutes from './routes/auth.routes';
import marketDataRoutes from './routes/market-data.routes';
import paperTradingRoutes from './routes/paper-trading.routes';

const app: Application = express();

// ‚úÖ CRITICAL: Middleware - MUST be before routes
app.use(cors({
  origin: ['http://localhost:3000', 'http://localhost:3001'],
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization']
}));

// ‚úÖ Parse JSON bodies (THIS WAS MISSING!)
app.use(express.json());

// ‚úÖ Parse URL-encoded bodies
app.use(express.urlencoded({ extended: true }));

// Root route
app.get('/', (req: Request, res: Response) => {
  res.json({
    message: 'üöÄ Paper Trading Backend with Upstox API',
    version: '1.0.0',
    status: 'operational',
    endpoints: {
      health: '/health',
      auth: '/auth/upstox/status',
      login: '/auth/upstox/login',
      marketData: '/api/market-data/ltp?symbols=NSE_EQ|INE002A01018',
      optionChain: '/api/market-data/option-chain?instrument_key=NSE_INDEX|Nifty%2050&expiry_date=2025-11-21',
      portfolio: '/api/paper-trading/portfolio',
      placeOrder: 'POST /api/paper-trading/order',
      orders: '/api/paper-trading/orders'
    }
  });
});

// Health check
app.get('/health', (req: Request, res: Response) => {
  res.status(200).json({ 
    status: 'OK',
    timestamp: new Date().toISOString(),
    uptime: process.uptime(),
    env: {
      PORT: process.env.PORT,
      NODE_ENV: process.env.NODE_ENV || 'development',
      UPSTOX_CONFIGURED: !!(process.env.UPSTOX_API_KEY && process.env.UPSTOX_API_SECRET)
    }
  });
});

// API Routes
app.use('/auth/upstox', authRoutes);
app.use('/api/market-data', marketDataRoutes);
app.use('/api/paper-trading', paperTradingRoutes);

// 404 handler
app.use((req: Request, res: Response) => {
  res.status(404).json({ 
    error: 'Route not found',
    path: req.path,
    method: req.method,
    availableRoutes: [
      'GET  /',
      'GET  /health',
      'GET  /auth/upstox/status',
      'GET  /auth/upstox/login',
      'GET  /auth/upstox/callback',
      'GET  /api/market-data/ltp',
      'GET  /api/market-data/quote',
      'GET  /api/market-data/option-chain',
      'GET  /api/paper-trading/portfolio',
      'POST /api/paper-trading/order',
      'GET  /api/paper-trading/orders',
      'GET  /api/paper-trading/positions',
      'POST /api/paper-trading/reset'
    ]
  });
});

// Error handler
app.use((err: Error, req: Request, res: Response, next: any) => {
  console.error('‚ùå Server Error:', err);
  res.status(500).json({ 
    error: 'Internal server error',
    message: err.message,
    timestamp: new Date().toISOString()
  });
});

// Start server
const PORT = process.env.PORT || 3001;

app.listen(PORT, () => {
  console.log('\n' + '='.repeat(70));
  console.log('üöÄ Paper Trading Backend Server Started');
  console.log('='.repeat(70));
  console.log(`üì° Server:        http://localhost:${PORT}`);
  console.log(`üè† Root:          http://localhost:${PORT}/`);
  console.log(`‚ù§Ô∏è  Health:        http://localhost:${PORT}/health`);
  console.log('‚îÄ'.repeat(70));
  console.log('üîê Authentication Routes:');
  console.log(`   GET  /auth/upstox/status`);
  console.log(`   GET  /auth/upstox/login`);
  console.log(`   GET  /auth/upstox/callback`);
  console.log('‚îÄ'.repeat(70));
  console.log('üìä Market Data Routes:');
  console.log(`   GET  /api/market-data/ltp?symbols=NSE_EQ|INE002A01018`);
  console.log(`   GET  /api/market-data/quote?symbols=NSE_EQ|INE002A01018`);
  console.log(`   GET  /api/market-data/option-chain?instrument_key=...&expiry_date=...`);
  console.log('‚îÄ'.repeat(70));
  console.log('üí∞ Paper Trading Routes:');
  console.log(`   GET  /api/paper-trading/portfolio`);
  console.log(`   POST /api/paper-trading/order`);
  console.log(`   GET  /api/paper-trading/orders`);
  console.log(`   GET  /api/paper-trading/positions`);
  console.log(`   POST /api/paper-trading/reset`);
  console.log('='.repeat(70));
  
  // Check environment
  const upstoxConfigured = !!(process.env.UPSTOX_API_KEY && process.env.UPSTOX_API_SECRET);
  
  if (upstoxConfigured) {
    console.log('‚úÖ Upstox API: Configured');
    console.log(`   API Key: ${process.env.UPSTOX_API_KEY?.substring(0, 10)}...`);
    console.log(`   Redirect URI: ${process.env.UPSTOX_REDIRECT_URI}`);
  } else {
    console.log('‚ö†Ô∏è  Upstox API: NOT CONFIGURED');
    console.log('   Create backend/.env.local with:');
    console.log('   UPSTOX_API_KEY=your_api_key');
    console.log('   UPSTOX_API_SECRET=your_api_secret');
    console.log('   UPSTOX_REDIRECT_URI=http://localhost:3001/auth/upstox/callback');
  }
  
  console.log('='.repeat(70));
  console.log('üìù Logs:');
  console.log('‚îÄ'.repeat(70) + '\n');
});

export default app;
</file>

<file path="backend/src/routes/auth.routes.ts">
import express from 'express';
import { upstoxService } from '../services/upstox.service';

const router = express.Router();

router.get('/upstox/login', (req, res) => {
  try {
    if (!process.env.UPSTOX_API_KEY || !process.env.UPSTOX_API_SECRET) {
      return res.status(500).json({
        error: 'Environment variables not configured',
        instructions: [
          '1. Create backend/.env.local file',
          '2. Add UPSTOX_API_KEY and UPSTOX_API_SECRET',
          '3. Restart backend server'
        ],
        env_status: {
          UPSTOX_API_KEY: process.env.UPSTOX_API_KEY ? '‚úì Set' : '‚úó Missing',
          UPSTOX_API_SECRET: process.env.UPSTOX_API_SECRET ? '‚úì Set' : '‚úó Missing'
        }
      });
    }

    const loginUrl = upstoxService.getLoginUrl();
    res.json({ 
      message: 'Copy the loginUrl and open it in your browser',
      loginUrl
    });
  } catch (error: any) {
    res.status(500).json({ error: error.message });
  }
});

router.get('/upstox/callback', async (req, res) => {
  try {
    const { code } = req.query;

    if (!code || typeof code !== 'string') {
      return res.status(400).send(`
        <html>
          <body style="font-family: Arial; padding: 50px; text-align: center;">
            <h1 style="color: red;">‚ùå Error</h1>
            <p>Authorization code missing</p>
            <a href="/auth/upstox/login">Try Again</a>
          </body>
        </html>
      `);
    }

    await upstoxService.authenticate(code);

    res.send(`
      <html>
        <head>
          <style>
            body {
              font-family: Arial, sans-serif;
              background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
              display: flex;
              justify-content: center;
              align-items: center;
              height: 100vh;
              margin: 0;
            }
            .container {
              background: white;
              padding: 50px;
              border-radius: 15px;
              box-shadow: 0 10px 50px rgba(0,0,0,0.3);
              text-align: center;
              max-width: 600px;
            }
            h1 { color: #4caf50; margin: 20px 0; }
            .icon { font-size: 80px; margin-bottom: 20px; }
            a { color: #667eea; text-decoration: none; font-weight: bold; }
          </style>
        </head>
        <body>
          <div class="container">
            <div class="icon">‚úÖ</div>
            <h1>Authentication Successful!</h1>
            <p>Your app is now connected to Upstox API</p>
            <p>You can close this window and start trading</p>
            <p style="margin-top: 30px;">
              <a href="http://localhost:3001/api/market-data/ltp?symbols=NSE_EQ|INE002A01018" target="_blank">
                Test Market Data ‚Üí
              </a>
            </p>
          </div>
        </body>
      </html>
    `);
  } catch (error: any) {
    res.status(500).send(`
      <html>
        <body style="font-family: Arial; padding: 50px; text-align: center;">
          <h1 style="color: red;">‚ùå Authentication Failed</h1>
          <p>${error.message}</p>
          <a href="/auth/upstox/login">Try Again</a>
        </body>
      </html>
    `);
  }
});

router.get('/upstox/status', (req, res) => {
  res.json({
    authenticated: upstoxService.isAuthenticated(),
    message: upstoxService.isAuthenticated() 
      ? '‚úì Connected to Upstox API' 
      : '‚úó Not authenticated',
    env_check: {
      UPSTOX_API_KEY: process.env.UPSTOX_API_KEY ? '‚úì' : '‚úó',
      UPSTOX_API_SECRET: process.env.UPSTOX_API_SECRET ? '‚úì' : '‚úó',
      UPSTOX_REDIRECT_URI: process.env.UPSTOX_REDIRECT_URI ? '‚úì' : '‚úó'
    }
  });
});

export default router;
</file>

<file path="backend/src/routes/market-data.routes.ts">
import express from 'express';
import { upstoxService } from '../services/upstox.service';

const router = express.Router();

router.get('/quote', async (req, res) => {
  try {
    const { symbols } = req.query;
    
    if (!symbols || typeof symbols !== 'string') {
      return res.status(400).json({ 
        error: 'symbols parameter required',
        example: '/api/market-data/quote?symbols=NSE_EQ|INE002A01018'
      });
    }

    const symbolArray = symbols.split(',');
    const data = await upstoxService.getMarketQuote(symbolArray);
    res.json(data);
  } catch (error: any) {
    res.status(500).json({ 
      error: error.message,
      hint: error.message.includes('Not authenticated') 
        ? 'Visit /auth/upstox/login to authenticate' 
        : undefined
    });
  }
});

router.get('/ltp', async (req, res) => {
  try {
    const { symbols } = req.query;
    
    if (!symbols || typeof symbols !== 'string') {
      return res.status(400).json({ 
        error: 'symbols parameter required',
        example: '/api/market-data/ltp?symbols=NSE_EQ|INE002A01018,NSE_EQ|INE467B01029'
      });
    }

    const symbolArray = symbols.split(',');
    const data = await upstoxService.getLTP(symbolArray);
    res.json(data);
  } catch (error: any) {
    res.status(500).json({ error: error.message });
  }
});

router.get('/option-chain', async (req, res) => {
  try {
    const { instrument_key, expiry_date } = req.query;
    
    if (!instrument_key || !expiry_date) {
      return res.status(400).json({ 
        error: 'instrument_key and expiry_date required',
        example: '/api/market-data/option-chain?instrument_key=NSE_INDEX|Nifty%2050&expiry_date=2025-11-28'
      });
    }

    const data = await upstoxService.getOptionChain(
      instrument_key as string,
      expiry_date as string
    );
    res.json(data);
  } catch (error: any) {
    res.status(500).json({ error: error.message });
  }
});

router.get('/historical', async (req, res) => {
  try {
    const { instrument_key, interval, from, to } = req.query;
    
    if (!instrument_key || !interval || !from || !to) {
      return res.status(400).json({ 
        error: 'All parameters required',
        example: '/api/market-data/historical?instrument_key=NSE_EQ|INE002A01018&interval=1day&from=2025-11-01&to=2025-11-15'
      });
    }

    const data = await upstoxService.getHistoricalData(
      instrument_key as string,
      interval as string,
      to as string,
      from as string
    );
    res.json(data);
  } catch (error: any) {
    res.status(500).json({ error: error.message });
  }
});

export default router;
</file>

<file path="backend/src/routes/market.routes.ts">
import express from 'express';

const router = express.Router();

// Route 1: Option chain data (fixes your first 404 error)
router.get('/option-chain', async (req, res) => {
  try {
    const { index } = req.query;
    
    if (!index) {
      return res.status(400).json({ 
        error: 'Index parameter is required',
        message: 'Please provide an index (e.g., NIFTY, BANKNIFTY)' 
      });
    }

    console.log(`üìä Fetching option chain for: ${index}`);

    const basePrice = index === 'NIFTY' ? 19850 : 45200;
    const strikeInterval = index === 'NIFTY' ? 50 : 100;
    const numberOfStrikes = 21;
    
    const chain = [];
    const startStrike = basePrice - (Math.floor(numberOfStrikes / 2) * strikeInterval);

    for (let i = 0; i < numberOfStrikes; i++) {
      const strike = startStrike + (i * strikeInterval);
      
      chain.push({
        strike: strike,
        CE: {
          tradingSymbol: `${index}${strike}CE`,
          strike: strike,
          optionType: 'CE',
          ltp: Math.random() * 200 + 50,
          bid: Math.random() * 190 + 45,
          ask: Math.random() * 210 + 55,
          volume: Math.floor(Math.random() * 500000) + 50000,
          oi: Math.floor(Math.random() * 5000000) + 500000,
          lotSize: index === 'NIFTY' ? 50 : 25,
          changePercent: (Math.random() - 0.5) * 20
        },
        PE: {
          tradingSymbol: `${index}${strike}PE`,
          strike: strike,
          optionType: 'PE',
          ltp: Math.random() * 200 + 50,
          bid: Math.random() * 190 + 45,
          ask: Math.random() * 210 + 55,
          volume: Math.floor(Math.random() * 500000) + 50000,
          oi: Math.floor(Math.random() * 5000000) + 500000,
          lotSize: index === 'NIFTY' ? 50 : 25,
          changePercent: (Math.random() - 0.5) * 20
        }
      });
    }

    const response = {
      index: index,
      chain: chain,
      timestamp: new Date().toISOString(),
      underlyingPrice: basePrice,
      success: true
    };

    console.log(`‚úÖ Returning ${chain.length} strikes for ${index}`);
    res.json(response);

  } catch (error) {
    console.error('‚ùå Error fetching option chain:', error);
    res.status(500).json({ 
      error: 'Failed to fetch option chain data',
      message: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

// Route 2: Market status
router.get('/status', async (req, res) => {
  try {
    res.json({
      marketStatus: 'OPEN',
      currentTime: new Date().toISOString(),
      tradingHours: {
        open: '09:15',
        close: '15:30'
      }
    });
  } catch (error) {
    console.error('Error fetching market status:', error);
    res.status(500).json({ error: 'Failed to fetch market status' });
  }
});

export default router;
</file>

<file path="backend/src/routes/order.routes.ts">
import express from 'express';
import { upstoxService } from '../services/upstox.service';

const router = express.Router();

// Place a new order
router.post('/place', async (req, res) => {
  try {
    const orderData = req.body;
    const result = await upstoxService.placeOrder(orderData);
    res.json(result);
  } catch (error: any) {
    res.status(500).json({ 
      error: 'Failed to place order',
      message: error.message 
    });
  }
});

// Get all orders
router.get('/', async (req, res) => {
  try {
    const orders = await upstoxService.getOrders();
    res.json(orders);
  } catch (error: any) {
    res.status(500).json({ 
      error: 'Failed to fetch orders',
      message: error.message 
    });
  }
});

export default router;
</file>

<file path="backend/src/routes/paper-trading.routes.ts">
import express from 'express';

const router = express.Router();

// In-memory storage (replace with database in production)
let portfolio = {
  balance: 1000000, // ‚Çπ10 lakh starting capital
  positions: [] as any[],
  orders: [] as any[]
};

// Get portfolio
router.get('/portfolio', (req, res) => {
  try {
    const totalPnL = portfolio.positions.reduce((sum, pos) => {
      return sum + (pos.quantity * (pos.currentPrice - pos.avgPrice));
    }, 0);

    res.json({
      balance: portfolio.balance,
      positions: portfolio.positions,
      totalPnL,
      totalValue: portfolio.balance + totalPnL
    });
  } catch (error: any) {
    console.error('Portfolio error:', error);
    res.status(500).json({ error: error.message });
  }
});

// Place order - THIS IS THE FIX
router.post('/order', (req, res) => {
  try {
    console.log('Received order:', req.body);

    const { symbol, quantity, price, side, type } = req.body;

    // Validate input
    if (!symbol || !quantity || !price || !side) {
      return res.status(400).json({ 
        error: 'Missing required fields: symbol, quantity, price, side' 
      });
    }

    // Create order object
    const order = {
      id: `ORDER_${Date.now()}`,
      symbol,
      quantity,
      price,
      side,
      type: type || 'MARKET',
      status: 'COMPLETED',
      timestamp: new Date().toISOString()
    };

    // Calculate order value
    const orderValue = quantity * price;

    // Check if user has enough balance for BUY orders
    if (side === 'BUY' && orderValue > portfolio.balance) {
      return res.status(400).json({ 
        error: 'Insufficient balance',
        required: orderValue,
        available: portfolio.balance
      });
    }

    // Update balance
    if (side === 'BUY') {
      portfolio.balance -= orderValue;
    } else if (side === 'SELL') {
      portfolio.balance += orderValue;
    }

    // Update positions
    const existingPositionIndex = portfolio.positions.findIndex(
      pos => pos.symbol === symbol
    );

    if (existingPositionIndex >= 0) {
      // Update existing position
      const pos = portfolio.positions[existingPositionIndex];
      
      if (side === 'BUY') {
        const totalQty = pos.quantity + quantity;
        pos.avgPrice = ((pos.avgPrice * pos.quantity) + (price * quantity)) / totalQty;
        pos.quantity = totalQty;
      } else if (side === 'SELL') {
        pos.quantity -= quantity;
        
        // Remove position if quantity becomes zero
        if (pos.quantity <= 0) {
          portfolio.positions.splice(existingPositionIndex, 1);
        }
      }
    } else if (side === 'BUY') {
      // Create new position
      portfolio.positions.push({
        symbol,
        quantity,
        avgPrice: price,
        currentPrice: price,
        pnl: 0
      });
    }

    // Add to orders history
    portfolio.orders.push(order);

    console.log('‚úÖ Order placed successfully:', order);
    console.log('üìä Updated portfolio:', {
      balance: portfolio.balance,
      positions: portfolio.positions.length
    });

    res.json({
      success: true,
      order,
      portfolio: {
        balance: portfolio.balance,
        positions: portfolio.positions
      }
    });
  } catch (error: any) {
    console.error('‚ùå Order placement error:', error);
    res.status(500).json({ 
      error: 'Internal server error',
      message: error.message 
    });
  }
});

// Get orders
router.get('/orders', (req, res) => {
  try {
    res.json({
      orders: portfolio.orders
    });
  } catch (error: any) {
    console.error('Orders error:', error);
    res.status(500).json({ error: error.message });
  }
});

// Get positions
router.get('/positions', (req, res) => {
  try {
    res.json({
      positions: portfolio.positions
    });
  } catch (error: any) {
    console.error('Positions error:', error);
    res.status(500).json({ error: error.message });
  }
});

// Reset portfolio (for testing)
router.post('/reset', (req, res) => {
  try {
    portfolio = {
      balance: 1000000,
      positions: [],
      orders: []
    };
    
    res.json({ 
      success: true,
      message: 'Portfolio reset to ‚Çπ10,00,000',
      portfolio 
    });
  } catch (error: any) {
    console.error('Reset error:', error);
    res.status(500).json({ error: error.message });
  }
});

export default router;
</file>

<file path="backend/src/routes/position.routes.ts">
import express from 'express';
import { upstoxService } from '../services/upstox.service';

const router = express.Router();

// Get all positions
router.get('/', async (req, res) => {
  try {
    const positions = await upstoxService.getPositions();
    res.json(positions);
  } catch (error: any) {
    res.status(500).json({ 
      error: 'Failed to fetch positions',
      message: error.message 
    });
  }
});

export default router;
</file>

<file path="backend/src/seed.ts">
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

async function seedIndices() {
  console.log('üå± Seeding indices...');
  
  const indices = [
    { symbol: 'NIFTY', displayName: 'NIFTY 50', lotSize: 75 },
    { symbol: 'BANKNIFTY', displayName: 'NIFTY BANK', lotSize: 25 },
    { symbol: 'FINNIFTY', displayName: 'FINNIFTY', lotSize: 40 },
    { symbol: 'MIDCPNIFTY', displayName: 'MIDCAP NIFTY', lotSize: 50 },
    { symbol: 'SENSEX', displayName: 'SENSEX', lotSize: 10 },
    { symbol: 'NIFTYIT', displayName: 'NIFTY IT', lotSize: 25 },
    { symbol: 'NIFTYPHARMA', displayName: 'NIFTY PHARMA', lotSize: 20 },
  ];

  for (const index of indices) {
    await prisma.index.upsert({
      where: { symbol: index.symbol },
      update: index,
      create: index
    });
  }
  
  console.log('‚úì Indices seeded - 7 indices created');
}

async function seedOptionContracts() {
  const indices = await prisma.index.findMany();
  
  for (const index of indices) {
    console.log(`üå± Seeding ${index.displayName} contracts...`);
    
    const basePrices: Record<string, number> = {
      'NIFTY': 25000,
      'BANKNIFTY': 55000,
      'FINNIFTY': 23500,
      'MIDCPNIFTY': 14500,
      'SENSEX': 84000,
      'NIFTYIT': 42000,
      'NIFTYPHARMA': 22000,
    };
    
    const basePrice = basePrices[index.symbol] || 25000;
    const atmStrike = Math.round(basePrice / 100) * 100;
    
    const strikes = [];
    const strikeInterval = index.symbol === 'SENSEX' ? 100 : 50;
    
    for (let i = -10; i <= 10; i++) {
      strikes.push(atmStrike + (i * strikeInterval));
    }
    
    const today = new Date();
    const daysUntilThursday = (4 - today.getDay() + 7) % 7 || 7;
    const expiry = new Date(today);
    expiry.setDate(today.getDate() + daysUntilThursday);
    expiry.setHours(15, 30, 0, 0);
    
    const expiryDateString = expiry.toISOString();
    
    for (const strike of strikes) {
      // CE (Call)
      try {
        await prisma.optionContract.upsert({
          where: {
            tradingSymbol: `${index.symbol}${expiry.getDate()}${expiry.toLocaleString('en-US', { month: 'short' }).toUpperCase()}${strike}CE`
          },
          update: {},
          create: {
            tradingSymbol: `${index.symbol}${expiry.getDate()}${expiry.toLocaleString('en-US', { month: 'short' }).toUpperCase()}${strike}CE`,
            indexSymbol: index.symbol,
            strike,
            optionType: 'CE',
            expiryDate: expiryDateString,
            lotSize: index.lotSize,
          }
        });
      } catch (error) {
        console.log(`Skipping ${index.symbol} ${strike}CE - already exists`);
      }
      
      // PE (Put)
      try {
        await prisma.optionContract.upsert({
          where: {
            tradingSymbol: `${index.symbol}${expiry.getDate()}${expiry.toLocaleString('en-US', { month: 'short' }).toUpperCase()}${strike}PE`
          },
          update: {},
          create: {
            tradingSymbol: `${index.symbol}${expiry.getDate()}${expiry.toLocaleString('en-US', { month: 'short' }).toUpperCase()}${strike}PE`,
            indexSymbol: index.symbol,
            strike,
            optionType: 'PE',
            expiryDate: expiryDateString,
            lotSize: index.lotSize,
          }
        });
      } catch (error) {
        console.log(`Skipping ${index.symbol} ${strike}PE - already exists`);
      }
    }
    
    console.log(`‚úì ${index.displayName} contracts seeded`);
  }
}

async function main() {
  console.log('üå± Starting database seed...\n');
  
  try {
    await seedIndices();
    await seedOptionContracts();
    
    console.log('\n‚úÖ Seed completed successfully!');
    console.log('üìä You can now use the trading app.\n');
  } catch (error) {
    console.error('‚ùå Error during seed:', error);
    throw error;
  } finally {
    await prisma.$disconnect();
  }
}

main()
  .catch((e) => {
    console.error(e);
    process.exit(1);
  });
</file>

<file path="backend/src/services/market-data.service.ts">
import axios from 'axios';

export class MarketDataService {
  private apiKey: string;
  private apiSecret: string;
  private baseUrl: string;

  constructor() {
    this.apiKey = process.env.API_KEY || '';
    this.apiSecret = process.env.API_SECRET || '';
    this.baseUrl = process.env.API_BASE_URL || '';
  }

  // Fetch current market price
  async getCurrentPrice(symbol: string): Promise<number> {
    try {
      const response = await axios.get(`${this.baseUrl}/price`, {
        params: { symbol },
        headers: {
          'X-API-Key': this.apiKey,
          'X-API-Secret': this.apiSecret
        }
      });
      return response.data.price;
    } catch (error) {
      console.error('Error fetching price:', error);
      throw error;
    }
  }

  // Fetch historical data
  async getHistoricalData(symbol: string, interval: string) {
    const response = await axios.get(`${this.baseUrl}/historical`, {
      params: { symbol, interval },
      headers: {
        'X-API-Key': this.apiKey
      }
    });
    return response.data;
  }
}
</file>

<file path="backend/src/services/order.service.ts">
import { PrismaClient } from '@prisma/client';
import { getLTP } from './quote.service';
import { calculateFees, roundToTick } from '../utils/helpers';
import { broadcastPnL } from './pnl.service';

const prisma = new PrismaClient();

export interface PlaceOrderParams {
  accountId: string;
  tradingSymbol: string;
  side: 'BUY' | 'SELL';
  lots: number;
  orderType: 'MARKET' | 'LIMIT' | 'SL' | 'SLM';
  limitPrice?: number;
  triggerPrice?: number;
}

export async function placeOrder(params: PlaceOrderParams) {
  const contract = await prisma.optionContract.findUnique({
    where: { tradingSymbol: params.tradingSymbol }
  });

  if (!contract) {
    throw new Error('Contract not found');
  }

  const order = await prisma.order.create({
    data: {
      accountId: params.accountId,
      contractId: contract.id,
      side: params.side,
      qty: params.lots,
      orderType: params.orderType,
      limitPrice: params.limitPrice,
      triggerPrice: params.triggerPrice,
      status: 'OPEN'
    }
  });

  await attemptFill(order.id);
  return order;
}

export async function attemptFill(orderId: string) {
  const order = await prisma.order.findUnique({
    where: { id: orderId },
    include: { contract: true }
  });

  if (!order || order.status !== 'OPEN') {
    return;
  }

  const ltp = await getLTP(order.contract.tradingSymbol);
  if (!ltp) {
    return;
  }

  let fillPrice: number | null = null;

  if (order.orderType === 'MARKET') {
    fillPrice = ltp;
  } else if (order.orderType === 'LIMIT' && order.limitPrice) {
    const limit = parseFloat(order.limitPrice.toString());
    if (
      (order.side === 'BUY' && ltp <= limit) ||
      (order.side === 'SELL' && ltp >= limit)
    ) {
      fillPrice = limit;
    }
  }

  if (fillPrice) {
    await executeFill(order.id, order.qty, roundToTick(fillPrice));
  }
}

async function executeFill(orderId: string, lots: number, price: number) {
  const order = await prisma.order.findUnique({
    where: { id: orderId },
    include: { contract: true, account: true }
  });

  if (!order) return;

  const units = lots * order.contract.lotSize;
  const premium = price * units;
  const fees = calculateFees(price, units);

  await prisma.trade.create({
    data: {
      orderId: order.id,
      contractId: order.contractId,
      side: order.side,
      qty: lots,
      price
    }
  });

  await prisma.order.update({
    where: { id: orderId },
    data: { status: 'FILLED' }
  });

  const existingPosition = await prisma.position.findUnique({
    where: {
      accountId_contractId: {
        accountId: order.accountId,
        contractId: order.contractId
      }
    }
  });

  if (existingPosition) {
    const currentNetLots = existingPosition.netLots;
    const currentAvgPrice = parseFloat(existingPosition.avgPrice.toString());
    const currentValue = currentNetLots * order.contract.lotSize * currentAvgPrice;

    const newLots = order.side === 'BUY' ? lots : -lots;
    const newNetLots = currentNetLots + newLots;

    if (newNetLots === 0) {
      await prisma.position.delete({
        where: { id: existingPosition.id }
      });

      const realizedPnL = (price - currentAvgPrice) * Math.abs(currentNetLots) * order.contract.lotSize;
      await prisma.cashLedger.create({
        data: {
          accountId: order.accountId,
          type: realizedPnL >= 0 ? 'CREDIT' : 'DEBIT',
          amount: Math.abs(realizedPnL),
          reason: 'REALIZED_PNL',
          refId: orderId
        }
      });
    } else {
      const newValue = currentValue + (newLots * order.contract.lotSize * price);
      const newAvgPrice = newValue / (newNetLots * order.contract.lotSize);

      await prisma.position.update({
        where: { id: existingPosition.id },
        data: {
          netLots: newNetLots,
          avgPrice: newAvgPrice
        }
      });
    }
  } else {
    await prisma.position.create({
      data: {
        accountId: order.accountId,
        contractId: order.contractId,
        netLots: order.side === 'BUY' ? lots : -lots,
        avgPrice: price
      }
    });
  }

  await prisma.cashLedger.create({
    data: {
      accountId: order.accountId,
      type: 'DEBIT',
      amount: fees,
      reason: 'TRADING_FEES',
      refId: orderId
    }
  });

  await prisma.cashLedger.create({
    data: {
      accountId: order.accountId,
      type: order.side === 'BUY' ? 'DEBIT' : 'CREDIT',
      amount: premium,
      reason: 'TRADE',
      refId: orderId
    }
  });

  await broadcastPnL(order.accountId);
}

export async function cancelOrder(orderId: string) {
  const order = await prisma.order.findUnique({
    where: { id: orderId }
  });

  if (!order || order.status !== 'OPEN') {
    throw new Error('Cannot cancel order');
  }

  await prisma.order.update({
    where: { id: orderId },
    data: { status: 'CANCELLED' }
  });

  return { success: true };
}
</file>

<file path="backend/src/services/pnl.service.ts">
import { PrismaClient } from '@prisma/client';
import Redis from 'ioredis';

const prisma = new PrismaClient();
const redis = new Redis(process.env.REDIS_URL!);

export interface PositionPnL {
  contractId: bigint;
  tradingSymbol: string;
  netLots: number;
  netUnits: number;
  avgPrice: number;
  ltp: number;
  mtm: number;
}

export interface AccountPnL {
  accountId: string;
  positions: PositionPnL[];
  totalMtm: number;
  realizedPnL: number;
  fees: number;
  netPnL: number;
  capitalUsed: number;
  capitalLeft: number;
}

export async function calculatePositionMTM(
  netLots: number,
  lotSize: number,
  avgPrice: number,
  ltp: number
): Promise<{ units: number; mtm: number }> {
  const units = netLots * lotSize;
  const mtm = units * (ltp - avgPrice);
  return { units, mtm };
}

export async function getAccountPnL(accountId: string): Promise<AccountPnL> {
  const account = await prisma.account.findUnique({
    where: { id: accountId },
    include: {
      positions: {
        include: {
          contract: true
        }
      }
    }
  });

  if (!account) {
    throw new Error('Account not found');
  }

  const positionPnLs: PositionPnL[] = [];
  let totalMtm = 0;

  for (const position of account.positions) {
    const ltp = await redis.get(`ltp:${position.contract.tradingSymbol}`);
    const currentLtp = ltp ? parseFloat(ltp) : parseFloat(position.avgPrice.toString());
    
    const { units, mtm } = await calculatePositionMTM(
      position.netLots,
      position.contract.lotSize,
      parseFloat(position.avgPrice.toString()),
      currentLtp
    );

    positionPnLs.push({
      contractId: position.contractId,
      tradingSymbol: position.contract.tradingSymbol,
      netLots: position.netLots,
      netUnits: units,
      avgPrice: parseFloat(position.avgPrice.toString()),
      ltp: currentLtp,
      mtm
    });

    totalMtm += mtm;
  }

  const ledgerEntries = await prisma.cashLedger.findMany({
    where: { accountId }
  });

  let realizedPnL = 0;
  let fees = 0;
  let capitalUsed = parseFloat(account.baseCapital.toString());

  ledgerEntries.forEach(entry => {
    const amount = parseFloat(entry.amount.toString());
    if (entry.type === 'CREDIT') {
      realizedPnL += amount;
    } else if (entry.type === 'DEBIT') {
      if (entry.reason?.includes('FEE')) {
        fees += amount;
      } else {
        capitalUsed -= amount;
      }
    }
  });

  const netPnL = totalMtm + realizedPnL - fees;
  const capitalLeft = capitalUsed + realizedPnL + totalMtm;

  return {
    accountId,
    positions: positionPnLs,
    totalMtm,
    realizedPnL,
    fees,
    netPnL,
    capitalUsed,
    capitalLeft
  };
}

export async function broadcastPnL(accountId: string): Promise<void> {
  const pnl = await getAccountPnL(accountId);
  await redis.publish(`pnl:${accountId}`, JSON.stringify(pnl));
}
</file>

<file path="backend/src/services/quote.service.ts">
interface Quote {
  ltp: number;
  bid: number;
  ask: number;
  volume: number;
  oi: number;
}

export async function getQuote(symbol: string): Promise<Quote> {
  const basePrice = Math.random() * 1000 + 100;
  
  return {
    ltp: parseFloat(basePrice.toFixed(2)),
    bid: parseFloat((basePrice * 0.98).toFixed(2)),
    ask: parseFloat((basePrice * 1.02).toFixed(2)),
    volume: Math.floor(Math.random() * 100000),
    oi: Math.floor(Math.random() * 1000000),
  };
}
</file>

<file path="backend/src/services/upstox.service.ts">
import axios from 'axios';
import * as fs from 'fs';
import * as path from 'path';

const UPSTOX_BASE_URL = 'https://api.upstox.com/v2';

interface TokenData {
  access_token: string;
  saved_at: string;
}

class UpstoxService {
  private accessToken: string | null = null;
  private tokenFilePath = path.join(__dirname, '../../.upstox-token.json');

  constructor() {
    this.loadToken();
  }

  private loadToken() {
    try {
      if (fs.existsSync(this.tokenFilePath)) {
        const data: TokenData = JSON.parse(fs.readFileSync(this.tokenFilePath, 'utf8'));
        this.accessToken = data.access_token;
        console.log('‚úÖ Upstox token loaded from file');
      }
    } catch (error) {
      console.log('‚ÑπÔ∏è  No saved token found');
    }
  }

  private saveToken(token: string) {
    try {
      const data: TokenData = {
        access_token: token,
        saved_at: new Date().toISOString()
      };
      fs.writeFileSync(this.tokenFilePath, JSON.stringify(data, null, 2));
      console.log('‚úÖ Token saved successfully');
    } catch (error) {
      console.error('‚ùå Error saving token:', error);
    }
  }

  isAuthenticated(): boolean {
    return this.accessToken !== null;
  }

  getLoginUrl(): string {
    const apiKey = process.env.UPSTOX_API_KEY;
    const redirectUri = process.env.UPSTOX_REDIRECT_URI;
    
    if (!apiKey || !redirectUri) {
      throw new Error('UPSTOX_API_KEY or UPSTOX_REDIRECT_URI not configured');
    }

    return `https://api.upstox.com/v2/login/authorization/dialog?response_type=code&client_id=${apiKey}&redirect_uri=${encodeURIComponent(redirectUri)}`;
  }

  async authenticate(authCode: string): Promise<void> {
    try {
      const response = await axios.post(
        `${UPSTOX_BASE_URL}/login/authorization/token`,
        new URLSearchParams({
          code: authCode,
          client_id: process.env.UPSTOX_API_KEY!,
          client_secret: process.env.UPSTOX_API_SECRET!,
          redirect_uri: process.env.UPSTOX_REDIRECT_URI!,
          grant_type: 'authorization_code'
        }),
        {
          headers: {
            'accept': 'application/json',
            'Api-Version': '2.0',
            'Content-Type': 'application/x-www-form-urlencoded'
          }
        }
      );

      this.accessToken = response.data.access_token;
      
      // ‚úÖ FIX: Check that accessToken is not null before saving
      if (this.accessToken) {
        this.saveToken(this.accessToken);
      }
      
      console.log('‚úÖ Upstox authentication successful');
    } catch (error: any) {
      console.error('‚ùå Authentication error:', error.response?.data || error.message);
      throw new Error('Failed to authenticate with Upstox');
    }
  }

  private async makeRequest(endpoint: string, params?: any): Promise<any> {
    if (!this.accessToken) {
      throw new Error('Not authenticated. Please authenticate first via /auth/upstox/login');
    }

    try {
      const response = await axios.get(`${UPSTOX_BASE_URL}${endpoint}`, {
        params,
        headers: {
          'Accept': 'application/json',
          'Api-Version': '2.0',
          'Authorization': `Bearer ${this.accessToken}`
        }
      });

      return response.data;
    } catch (error: any) {
      if (error.response?.status === 401) {
        this.accessToken = null;
        if (fs.existsSync(this.tokenFilePath)) {
          fs.unlinkSync(this.tokenFilePath);
        }
        throw new Error('Token expired. Please re-authenticate via /auth/upstox/login');
      }
      throw error;
    }
  }

  async getMarketQuote(symbols: string[]): Promise<any> {
    const symbolParam = symbols.join(',');
    return this.makeRequest('/market-quote/quotes', { symbol: symbolParam });
  }

  async getLTP(symbols: string[]): Promise<any> {
    const symbolParam = symbols.join(',');
    return this.makeRequest('/market-quote/ltp', { symbol: symbolParam });
  }

  async getOptionChain(instrumentKey: string, expiryDate: string): Promise<any> {
    return this.makeRequest('/option/chain', {
      instrument_key: instrumentKey,
      expiry_date: expiryDate
    });
  }

  async getHistoricalData(
    instrumentKey: string,
    interval: string,
    toDate: string,
    fromDate: string
  ): Promise<any> {
    return this.makeRequest(
      `/historical-candle/${instrumentKey}/${interval}/${toDate}/${fromDate}`
    );
  }
}

export const upstoxService = new UpstoxService();
</file>

<file path="backend/src/utils/helpers.ts">
import { FEES } from '../config/constants';

export function calculateFees(premium: number, qty: number): number {
  const turnover = premium * qty;
  const brokerage = turnover * FEES.brokerage;
  const exchangeFee = turnover * FEES.exchangeTxn;
  const gst = brokerage * FEES.gst;
  const sebi = turnover * FEES.sebi;
  const stamp = turnover * FEES.stampDuty;
  
  return brokerage + exchangeFee + gst + sebi + stamp;
}

export function roundToTick(price: number, tickSize: number = 0.05): number {
  return Math.round(price / tickSize) * tickSize;
}

export function generateTradingSymbol(
  index: string,
  expiry: Date,
  strike: number,
  optionType: 'CE' | 'PE'
): string {
  const year = expiry.getFullYear().toString().slice(-2);
  const months = ['JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC'];
  const month = months[expiry.getMonth()];
  const day = expiry.getDate().toString().padStart(2, '0');
  
  return `${index}${year}${month}${day}${strike}${optionType}`;
}

export function calculateIntrinsicValue(
  optionType: 'CE' | 'PE',
  strike: number,
  underlyingPrice: number
): number {
  if (optionType === 'CE') {
    return Math.max(0, underlyingPrice - strike);
  } else {
    return Math.max(0, strike - underlyingPrice);
  }
}
// backend/src/utils/toSafeJson.ts

export function toSafeJson(obj: any): any {
  // Recursively converts all BigInt values in an object/array to string
  if (Array.isArray(obj)) {
    return obj.map(toSafeJson);
  } else if (obj && typeof obj === 'object') {
    const newObj: any = {};
    for (const key of Object.keys(obj)) {
      if (typeof obj[key] === 'bigint') {
        newObj[key] = obj[key].toString();
      } else if (typeof obj[key] === 'object') {
        newObj[key] = toSafeJson(obj[key]);
      } else {
        newObj[key] = obj[key];
      }
    }
    return newObj;
  }
  return obj;
}
</file>

<file path="backend/src/websocket/ws.server.ts">
import WebSocket from 'ws';

export class MarketDataWebSocket {
  private ws: WebSocket | null = null;
  private reconnectInterval: number = 5000;

  connect(onMessage: (data: any) => void) {
    const wsUrl = `${process.env.WS_API_URL}?apiKey=${process.env.API_KEY}`;
    
    this.ws = new WebSocket(wsUrl);

    this.ws.on('open', () => {
      console.log('WebSocket connected');
      // Subscribe to market data streams
      this.subscribe(['AAPL', 'GOOGL', 'MSFT']);
    });

    this.ws.on('message', (data: string) => {
      const parsedData = JSON.parse(data);
      onMessage(parsedData);
    });

    this.ws.on('error', (error) => {
      console.error('WebSocket error:', error);
    });

    this.ws.on('close', () => {
      console.log('WebSocket closed, reconnecting...');
      setTimeout(() => this.connect(onMessage), this.reconnectInterval);
    });
  }

  subscribe(symbols: string[]) {
    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
      this.ws.send(JSON.stringify({
        action: 'subscribe',
        symbols: symbols
      }));
    }
  }

  disconnect() {
    if (this.ws) {
      this.ws.close();
    }
  }
}
</file>

<file path="backend/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "lib": ["ES2020"],
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "moduleResolution": "node"
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}
</file>

<file path="frontend/.gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
</file>

<file path="frontend/app/globals.css">
@import "tailwindcss";

:root {
  --background: #ffffff;
  --foreground: #171717;
}

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}

body {
  background: var(--background);
  color: var(--foreground);
  font-family: Arial, Helvetica, sans-serif;
}
@keyframes scroll-slow {
  0% {
    transform: translateX(0);
  }
  100% {
    transform: translateX(-50%);
  }
}

.animate-scroll-slow {
  animation: scroll-slow 60s linear infinite;
  display: inline-block;
}

.animate-scroll-slow:hover {
  animation-play-state: paused;
}
@keyframes slide-in {
  from {
    transform: translateX(100%);
    opacity: 0;
  }
  to {
    transform: translateX(0);
    opacity: 1;
  }
}

.animate-slide-in {
  animation: slide-in 0.3s ease-out;
}
</file>

<file path="frontend/app/layout.tsx">
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        {children}
      </body>
    </html>
  );
}
</file>

<file path="frontend/app/login/page.tsx">
'use client';

import { useState } from 'react';
import { useRouter } from 'next/navigation';
import axios from 'axios';

export default function Login() {
  const router = useRouter();
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [isRegister, setIsRegister] = useState(false);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');

  async function handleSubmit(e: React.FormEvent) {
    e.preventDefault();
    setError('');
    setLoading(true);
    
    try {
      const apiUrl = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:4000/api';
      const endpoint = isRegister ? '/auth/register' : '/auth/login';
      
      const { data } = await axios.post(apiUrl + endpoint, { email, password });
      
      localStorage.setItem('token', data.token);
      localStorage.setItem('user', JSON.stringify(data.user));
      localStorage.setItem('account', JSON.stringify(data.account));
      
      router.push('/trading');
    } catch (error: any) {
      setError(error.response?.data?.error || 'Authentication failed!');
      console.error('Login error:', error);
    } finally {
      setLoading(false);
    }
  }

  return (
    <div className="min-h-screen flex items-center justify-center bg-gradient-to-br from-blue-50 to-indigo-100">
      <div className="bg-white p-8 rounded-2xl shadow-xl w-96">
        <div className="text-center mb-8">
          <h1 className="text-3xl font-bold text-gray-800 mb-2">
            üìà Paper Trading
          </h1>
          <p className="text-gray-600">
            {isRegister ? 'Create your account' : 'Welcome back!'}
          </p>
        </div>
        
        {error && (
          <div className="mb-4 p-3 bg-red-100 border border-red-400 text-red-700 rounded-lg text-sm">
            {error}
          </div>
        )}
        
        <form onSubmit={handleSubmit} className="space-y-4">
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">
              Email
            </label>
            <input
              type="email"
              placeholder="your@email.com"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
              required
            />
          </div>
          
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">
              Password
            </label>
            <input
              type="password"
              placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
              required
            />
          </div>
          
          <button
            type="submit"
            disabled={loading}
            className="w-full bg-blue-600 text-white py-2 rounded-lg hover:bg-blue-700 disabled:bg-gray-400 font-medium transition"
          >
            {loading ? 'Please wait...' : (isRegister ? 'Register' : 'Login')}
          </button>
        </form>
        
        <div className="mt-6 text-center">
          <button
            onClick={() => setIsRegister(!isRegister)}
            className="text-blue-600 hover:underline text-sm"
          >
            {isRegister ? 'Already have an account? Login' : 'Need an account? Register'}
          </button>
        </div>

        {isRegister && (
          <div className="mt-4 p-3 bg-green-50 border border-green-200 rounded-lg text-xs text-green-800">
            üéâ New users get ‚Çπ1,00,000 virtual capital!
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="frontend/app/page.tsx">
"use client";

import { useEffect } from "react";
import { useRouter } from "next/navigation";

export default function Home() {
  const router = useRouter();

  useEffect(() => {
    // Directly redirect to trading page (no login required)
    router.push("/trading");
  }, [router]);

  return (
    <div className="min-h-screen flex items-center justify-center">
      Loading...
    </div>
  );
}
</file>

<file path="frontend/app/trading/page.tsx">
"use client";

import { useState } from "react";
import OptionChain from "../../components/OptionChain";
import Positions from "../../components/Positions";
import OrderHistory from "../../components/OrderHistory";
import { ToastProvider } from "../../components/ToastContainer";

export default function TradingPage() {
  const [activeTab, setActiveTab] = useState<"chain" | "positions">("chain");

  return (
    <ToastProvider>
      <div className="min-h-screen flex flex-col bg-gray-900">
        {/* Header with Logo */}
        <header className="bg-gradient-to-r from-blue-600 to-indigo-700 text-white px-6 py-4 shadow-lg">
          <h1 className="text-3xl font-bold">PaperBull</h1>
          <p className="text-sm text-blue-100 mt-1">Virtual Trading Platform</p>
        </header>

        {/* Tab Navigation */}
        <nav className="bg-gray-800 border-b border-gray-700 px-6">
          <div className="flex gap-8">
            <button
              onClick={() => setActiveTab("chain")}
              className={`py-3 px-2 font-medium border-b-2 transition ${
                activeTab === "chain"
                  ? "border-blue-500 text-blue-400"
                  : "border-transparent text-gray-400 hover:text-gray-200"
              }`}
            >
              Option chain
            </button>
            <button
              onClick={() => setActiveTab("positions")}
              className={`py-3 px-2 font-medium border-b-2 transition ${
                activeTab === "positions"
                  ? "border-blue-500 text-blue-400"
                  : "border-transparent text-gray-400 hover:text-gray-200"
              }`}
            >
              Positions
            </button>
          </div>
        </nav>

        {/* Main Content */}
        <main className="flex-1 overflow-auto">
          {activeTab === "chain" && <OptionChain />}
          {activeTab === "positions" && <Positions />}
        </main>
      </div>
    </ToastProvider>
  );
}
</file>

<file path="frontend/components/MarketClosedModal.tsx">
"use client";

interface MarketClosedModalProps {
  isOpen: boolean;
  onClose: () => void;
}

export default function MarketClosedModal({ isOpen, onClose }: MarketClosedModalProps) {
  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
      <div className="bg-gray-800 rounded-lg p-6 w-full max-w-md mx-4 border border-gray-700">
        {/* Icon */}
        <div className="flex justify-center mb-4">
          <div className="text-6xl">üîí</div>
        </div>

        {/* Title */}
        <h2 className="text-xl font-bold text-white text-center mb-2">
          Market is Closed
        </h2>

        {/* Message */}
        <p className="text-gray-400 text-center mb-6">
          Trading is only available during market hours: <br />
          <span className="text-white font-semibold">9:15 AM - 3:30 PM IST</span>
          <br />
          <span className="text-sm text-gray-500 mt-2 block">Monday to Friday</span>
        </p>

        {/* Button */}
        <button
          onClick={onClose}
          className="w-full py-3 bg-blue-600 hover:bg-blue-700 text-white rounded font-semibold transition"
        >
          Got it
        </button>
      </div>
    </div>
  );
}
</file>

<file path="frontend/components/MarketTicker.tsx">
'use client';

import { useState, useEffect } from 'react';

interface IndexData {
  name: string;
  value: number;
  change: number;
  changePercent: number;
}

export default function MarketTicker({ darkMode }: { darkMode: boolean }) {
  const [indices, setIndices] = useState<IndexData[]>([
    { name: 'NIFTY 50', value: 25492.30, change: -17.40, changePercent: -0.07 },
    { name: 'SENSEX', value: 84449.90, change: -55.47, changePercent: -0.07 },
    { name: 'NIFTY BANK', value: 55123.75, change: 123.45, changePercent: 0.22 },
    { name: 'FINNIFTY', value: 23850.60, change: -45.20, changePercent: -0.19 },
    { name: 'MIDCAP NIFTY', value: 14567.80, change: 89.30, changePercent: 0.62 },
    { name: 'NIFTY IT', value: 42346.50, change: -120.30, changePercent: -0.28 },
    { name: 'NIFTY PHARMA', value: 22145.90, change: 67.80, changePercent: 0.31 },
    { name: 'NIFTY AUTO', value: 25678.40, change: 145.60, changePercent: 0.57 },
    { name: 'BSE SENSEX', value: 84449.90, change: -55.47, changePercent: -0.07 },
    { name: 'BSE 500', value: 45123.60, change: 234.50, changePercent: 0.52 },
    { name: 'NIFTY SMALLCAP', value: 18234.70, change: -89.20, changePercent: -0.49 },
    { name: 'INDIA VIX', value: 13.45, change: -0.23, changePercent: -1.68 },
  ]);

  useEffect(() => {
    const interval = setInterval(() => {
      setIndices(prev => prev.map(idx => ({
        ...idx,
        value: idx.value + (Math.random() - 0.5) * 10,
        change: idx.change + (Math.random() - 0.5) * 2,
        changePercent: idx.changePercent + (Math.random() - 0.5) * 0.1,
      })));
    }, 3000);

    return () => clearInterval(interval);
  }, []);

  const textClass = darkMode ? 'text-gray-300' : 'text-gray-700';

  return (
    <div className="flex gap-8 px-4">
      {[...indices, ...indices].map((index, idx) => (
        <div key={idx} className="flex items-center gap-3 min-w-fit">
          <span className={`font-semibold ${textClass}`}>{index.name}</span>
          <span className={`font-bold ${index.change >= 0 ? 'text-green-400' : 'text-red-400'}`}>
            {index.value.toFixed(2)}
          </span>
          <span className={`text-sm ${index.change >= 0 ? 'text-green-400' : 'text-red-400'}`}>
            {index.change >= 0 ? '‚ñ≤' : '‚ñº'} {Math.abs(index.change).toFixed(2)} ({index.changePercent >= 0 ? '+' : ''}{index.changePercent.toFixed(2)}%)
          </span>
        </div>
      ))}
    </div>
  );
}
</file>

<file path="frontend/components/OptionChain.tsx">
"use client";

import { useState, useEffect } from "react";
import { isMarketOpen, getMarketStatus } from "../utils/marketStatus";

export default function OptionChain() {
  const [marketStatus, setMarketStatus] = useState({ isOpen: false, message: "" });

  useEffect(() => {
    // Check market status
    const status = getMarketStatus();
    setMarketStatus(status);

    // Update every minute
    const interval = setInterval(() => {
      const newStatus = getMarketStatus();
      setMarketStatus(newStatus);
    }, 60000);

    return () => clearInterval(interval);
  }, []);

  // If market is closed, show only the closed message
  if (!marketStatus.isOpen) {
    return (
      <div className="flex items-center justify-center min-h-[500px] p-6">
        <div className="text-center max-w-md">
          {/* Icon */}
          <div className="flex justify-center mb-6">
            <div className="text-8xl">üîí</div>
          </div>

          {/* Title */}
          <h2 className="text-3xl font-bold text-white mb-4">
            Market is Closed
          </h2>

          {/* Message */}
          <p className="text-gray-400 text-lg mb-3">
            Trading is only available during market hours:
          </p>
          
          <div className="bg-gray-800 rounded-lg p-4 mb-4">
            <p className="text-2xl font-bold text-blue-400">
              9:15 AM - 3:30 PM IST
            </p>
            <p className="text-sm text-gray-500 mt-2">Monday to Friday</p>
          </div>

          {/* Current Status */}
          <div className="mt-6 p-4 bg-gray-800 rounded-lg border border-gray-700">
            <p className="text-sm text-gray-400">Current Status:</p>
            <p className="text-lg font-semibold text-red-400">{marketStatus.message}</p>
          </div>

          {/* Info */}
          <p className="text-sm text-gray-500 mt-6">
            You can view your positions and order history while the market is closed.
          </p>
        </div>
      </div>
    );
  }

  // When market is open, show the full option chain
  return (
    <div className="p-6">
      <div className="text-center text-gray-400 py-8">
        <p className="text-green-400 font-semibold mb-2">‚úì Market is Open</p>
        <p>Option chain will load here when market is open</p>
      </div>
    </div>
  );
}
</file>

<file path="frontend/components/OrderHistory.tsx">
'use client';

import { useState, useEffect } from 'react';

interface Order {
  id: string;
  symbol: string;
  quantity: number;
  price: number;
  side: 'BUY' | 'SELL';
  type: string;
  status: string;
  timestamp: string;
}

interface GroupedOrders {
  [date: string]: Order[];
}

export default function OrderHistory() {
  const [orders, setOrders] = useState<Order[]>([]);
  const [groupedOrders, setGroupedOrders] = useState<GroupedOrders>({});
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState('');

  useEffect(() => {
    fetchOrders();
    
    // Auto-refresh every 10 seconds
    const interval = setInterval(fetchOrders, 10000);
    
    return () => clearInterval(interval);
  }, []);

  async function fetchOrders() {
    try {
      setLoading(true);
      setError('');

      const apiUrl = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3001';
      
      console.log('Fetching orders from:', `${apiUrl}/api/paper-trading/orders`);
      
      const response = await fetch(`${apiUrl}/api/paper-trading/orders`);
      
      if (!response.ok) {
        throw new Error(`Failed to fetch orders: ${response.status}`);
      }

      const data = await response.json();
      
      console.log('Orders data received:', data);
      
      const ordersList = data.orders || [];
      
      // Sort orders by timestamp (newest first)
      const sortedOrders = ordersList.sort((a: Order, b: Order) => {
        return new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime();
      });
      
      // Group orders by date
      const grouped = sortedOrders.reduce((acc: GroupedOrders, order: Order) => {
        const date = new Date(order.timestamp).toLocaleDateString('en-IN', {
          year: 'numeric',
          month: 'short',
          day: 'numeric'
        });
        
        if (!acc[date]) {
          acc[date] = [];
        }
        
        acc[date].push(order);
        return acc;
      }, {});
      
      setOrders(sortedOrders);
      setGroupedOrders(grouped);

    } catch (err: any) {
      console.error('Error fetching orders:', err);
      setError(err.message || 'Failed to load order history');
    } finally {
      setLoading(false);
    }
  }

  function formatTime(timestamp: string): string {
    return new Date(timestamp).toLocaleTimeString('en-IN', {
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit',
      hour12: true
    });
  }

  function formatDate(timestamp: string): string {
    return new Date(timestamp).toLocaleDateString('en-IN', {
      weekday: 'short',
      year: 'numeric',
      month: 'short',
      day: 'numeric'
    });
  }

  if (loading && orders.length === 0) {
    return (
      <div className="text-center py-8">
        <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-500 mx-auto mb-4"></div>
        <div className="text-gray-400">Loading order history...</div>
      </div>
    );
  }

  return (
    <div className="bg-gray-800 rounded-lg p-6 border border-gray-700">
      <div className="flex justify-between items-center mb-4">
        <div>
          <h2 className="text-xl font-bold">Order History</h2>
          <div className="text-sm text-gray-400 mt-1">
            Total Orders: {orders.length}
          </div>
        </div>
        <button
          onClick={fetchOrders}
          className="px-3 py-1 bg-blue-600 hover:bg-blue-700 text-sm rounded transition"
        >
          üîÑ Refresh
        </button>
      </div>

      {error && (
        <div className="bg-red-900/20 border border-red-700 text-red-300 px-4 py-2 rounded mb-4">
          {error}
        </div>
      )}

      {orders.length === 0 ? (
        <div className="text-center py-12">
          <div className="text-6xl mb-4">üìù</div>
          <div className="text-xl text-gray-400 mb-2">No orders yet</div>
          <div className="text-sm text-gray-500">Your order history will appear here</div>
        </div>
      ) : (
        <div className="space-y-6">
          {Object.entries(groupedOrders).map(([date, dateOrders]) => (
            <div key={date} className="border border-gray-700 rounded-lg overflow-hidden">
              {/* Date Header */}
              <div className="bg-gray-700/50 px-4 py-2 font-semibold text-sm flex justify-between items-center">
                <span>üìÖ {date}</span>
                <span className="text-gray-400">{dateOrders.length} orders</span>
              </div>

              {/* Orders Table */}
              <div className="overflow-x-auto">
                <table className="w-full text-sm">
                  <thead className="bg-gray-900/50">
                    <tr>
                      <th className="p-3 text-left">Time</th>
                      <th className="p-3 text-left">Order ID</th>
                      <th className="p-3 text-left">Symbol</th>
                      <th className="p-3 text-center">Type</th>
                      <th className="p-3 text-right">Qty</th>
                      <th className="p-3 text-right">Price</th>
                      <th className="p-3 text-right">Total</th>
                      <th className="p-3 text-center">Status</th>
                    </tr>
                  </thead>
                  <tbody>
                    {dateOrders.map((order) => {
                      const total = order.quantity * order.price;
                      
                      return (
                        <tr key={order.id} className="border-b border-gray-700/50 hover:bg-gray-700/30">
                          <td className="p-3 text-gray-400">{formatTime(order.timestamp)}</td>
                          <td className="p-3 font-mono text-xs">{order.id}</td>
                          <td className="p-3 font-semibold">{order.symbol}</td>
                          <td className="p-3 text-center">
                            <span className={`px-2 py-1 rounded text-xs font-semibold ${
                              order.side === 'BUY' 
                                ? 'bg-green-900/30 text-green-400' 
                                : 'bg-red-900/30 text-red-400'
                            }`}>
                              {order.side}
                            </span>
                          </td>
                          <td className="p-3 text-right">{order.quantity}</td>
                          <td className="p-3 text-right">‚Çπ{order.price.toFixed(2)}</td>
                          <td className="p-3 text-right font-semibold">‚Çπ{total.toFixed(2)}</td>
                          <td className="p-3 text-center">
                            <span className={`px-2 py-1 rounded text-xs font-semibold ${
                              order.status === 'COMPLETED' 
                                ? 'bg-blue-900/30 text-blue-400' 
                                : order.status === 'PENDING'
                                ? 'bg-yellow-900/30 text-yellow-400'
                                : 'bg-red-900/30 text-red-400'
                            }`}>
                              {order.status}
                            </span>
                          </td>
                        </tr>
                      );
                    })}
                  </tbody>
                </table>
              </div>
            </div>
          ))}
        </div>
      )}
    </div>
  );
}
</file>

<file path="frontend/components/OrderModal.tsx">
'use client';

import { useState, useEffect } from 'react';

export interface OrderDetails {
  side: 'BUY' | 'SELL';
  lots: number;
  orderType: 'MARKET' | 'LIMIT' | 'SL' | 'SL-M';
  limitPrice?: number;
  triggerPrice?: number;
}

interface OrderModalProps {
  isOpen: boolean;
  onClose: () => void;
  onSubmit: (orderDetails: OrderDetails) => void;
  contract: any;
  initialSide: 'BUY' | 'SELL';
}

export default function OrderModal({ isOpen, onClose, onSubmit, contract, initialSide }: OrderModalProps) {
  const [side, setSide] = useState<'BUY' | 'SELL'>(initialSide);
  const [lots, setLots] = useState(1);
  const [orderType, setOrderType] = useState<'MARKET' | 'LIMIT' | 'SL' | 'SL-M'>('MARKET');
  const [limitPrice, setLimitPrice] = useState('');
  const [triggerPrice, setTriggerPrice] = useState('');

  useEffect(() => {
    setSide(initialSide);
  }, [initialSide]);

  useEffect(() => {
    if (contract) {
      setLimitPrice(contract.ltp.toFixed(2));
      setTriggerPrice(contract.ltp.toFixed(2));
    }
  }, [contract]);

  if (!isOpen || !contract) return null;

  function handleSubmit() {
    const orderDetails: OrderDetails = {
      side,
      lots,
      orderType,
      limitPrice: limitPrice ? parseFloat(limitPrice) : undefined,
      triggerPrice: triggerPrice ? parseFloat(triggerPrice) : undefined,
    };

    onSubmit(orderDetails);
  }

  const totalValue = contract.ltp * lots * contract.lotSize;

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
      <div className="bg-gray-800 rounded-lg p-6 w-full max-w-md">
        <div className="flex justify-between items-center mb-4">
          <h2 className="text-xl font-bold text-white">{contract.tradingSymbol}</h2>
          <button onClick={onClose} className="text-gray-400 hover:text-white text-2xl">√ó</button>
        </div>

        <div className="space-y-4">
          {/* Buy/Sell Toggle */}
          <div className="flex gap-2">
            <button
              onClick={() => setSide('BUY')}
              className={`flex-1 py-2 rounded font-medium ${
                side === 'BUY' ? 'bg-green-600 text-white' : 'bg-gray-700 text-gray-300'
              }`}
            >
              BUY
            </button>
            <button
              onClick={() => setSide('SELL')}
              className={`flex-1 py-2 rounded font-medium ${
                side === 'SELL' ? 'bg-red-600 text-white' : 'bg-gray-700 text-gray-300'
              }`}
            >
              SELL
            </button>
          </div>

          {/* Lots */}
          <div>
            <label className="block text-sm text-gray-400 mb-2">Quantity (Lots)</label>
            <input
              type="number"
              value={lots}
              onChange={(e) => setLots(parseInt(e.target.value) || 1)}
              min="1"
              className="w-full px-3 py-2 bg-gray-700 text-white rounded"
            />
            <p className="text-xs text-gray-400 mt-1">
              {lots} lot(s) = {lots * contract.lotSize} qty
            </p>
          </div>

          {/* Order Type */}
          <div>
            <label className="block text-sm text-gray-400 mb-2">Order Type</label>
            <select
              value={orderType}
              onChange={(e) => setOrderType(e.target.value as any)}
              className="w-full px-3 py-2 bg-gray-700 text-white rounded"
            >
              <option value="MARKET">Market</option>
              <option value="LIMIT">Limit</option>
              <option value="SL">Stop Loss</option>
              <option value="SL-M">Stop Loss Market</option>
            </select>
          </div>

          {/* Limit Price */}
          {(orderType === 'LIMIT' || orderType === 'SL') && (
            <div>
              <label className="block text-sm text-gray-400 mb-2">Limit Price</label>
              <input
                type="number"
                value={limitPrice}
                onChange={(e) => setLimitPrice(e.target.value)}
                step="0.05"
                className="w-full px-3 py-2 bg-gray-700 text-white rounded"
              />
            </div>
          )}

          {/* Trigger Price */}
          {(orderType === 'SL' || orderType === 'SL-M') && (
            <div>
              <label className="block text-sm text-gray-400 mb-2">Trigger Price</label>
              <input
                type="number"
                value={triggerPrice}
                onChange={(e) => setTriggerPrice(e.target.value)}
                step="0.05"
                className="w-full px-3 py-2 bg-gray-700 text-white rounded"
              />
            </div>
          )}

          {/* Total Value */}
          <div className="bg-gray-700 p-3 rounded">
            <div className="flex justify-between text-sm">
              <span className="text-gray-400">Total Value</span>
              <span className="text-white font-bold">‚Çπ{totalValue.toFixed(2)}</span>
            </div>
          </div>

          {/* Submit Button */}
          <button
            onClick={handleSubmit}
            className={`w-full py-3 rounded font-bold text-white ${
              side === 'BUY' ? 'bg-green-600 hover:bg-green-700' : 'bg-red-600 hover:bg-red-700'
            }`}
          >
            Place {side} Order
          </button>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="frontend/components/Positions.tsx">
'use client';
import OrderHistory from './OrderHistory';
import { useState, useEffect } from 'react';

interface Position {
  symbol: string;
  quantity: number;
  avgPrice: number;
  currentPrice: number;
  pnl: number;
}

interface PnL {
  realized: number;
  unrealized: number;
  total: number;
}

export default function Positions() {
  const [positions, setPositions] = useState<Position[]>([]);
  const [pnl, setPnl] = useState<PnL>({ realized: 0, unrealized: 0, total: 0 });
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState('');

  useEffect(() => {
    fetchData();
    
    // Auto-refresh every 5 seconds
    const interval = setInterval(fetchData, 5000);
    
    return () => clearInterval(interval);
  }, []);

  async function fetchData() {
    try {
      setLoading(true);
      setError('');

      const apiUrl = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3001';
      
      console.log('Fetching positions from:', `${apiUrl}/api/paper-trading/portfolio`);
      
      // Fetch portfolio data from paper trading API
      const response = await fetch(`${apiUrl}/api/paper-trading/portfolio`);
      
      if (!response.ok) {
        throw new Error(`Failed to fetch portfolio: ${response.status}`);
      }

      const portfolioData = await response.json();
      
      console.log('Portfolio data received:', portfolioData);
      
      // Extract positions and calculate P&L
      const positionsList = portfolioData.positions || [];
      const totalPnL = positionsList.reduce((sum: number, pos: Position) => {
        return sum + (pos.pnl || 0);
      }, 0);
      
      setPositions(positionsList);
      setPnl({
        realized: 0,
        unrealized: totalPnL,
        total: totalPnL
      });

    } catch (err: any) {
      console.error('Error fetching positions:', err);
      setError(err.message || 'Failed to load positions');
    } finally {
      setLoading(false);
    }
  }

  if (loading && positions.length === 0) {
    return (
      <div className="text-center py-8">
        <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-500 mx-auto mb-4"></div>
        <div className="text-gray-400">Loading positions...</div>
      </div>
    );
  }

    return (
    <div className="space-y-6">
      {/* Portfolio Summary */}
      <div className="bg-gray-800 rounded-lg p-6 border border-gray-700">
        <h2 className="text-xl font-bold mb-4">Portfolio Summary</h2>
        <div className="grid grid-cols-3 gap-6">
          <div>
            <div className="text-gray-400 text-sm mb-1">Total Positions</div>
            <div className="text-2xl font-bold">{positions.length}</div>
          </div>
          <div>
            <div className="text-gray-400 text-sm mb-1">Total P&L</div>
            <div className={`text-2xl font-bold ${pnl.total >= 0 ? 'text-green-400' : 'text-red-400'}`}>
              ‚Çπ{pnl.total.toFixed(2)}
            </div>
          </div>
          <div>
            <div className="text-gray-400 text-sm mb-1">Capital Used</div>
            <div className="text-2xl font-bold">
              ‚Çπ{positions.reduce((sum, pos) => sum + (pos.avgPrice * pos.quantity), 0).toFixed(2)}
            </div>
          </div>
        </div>
      </div>

      {/* Open Positions */}
      <div className="bg-gray-800 rounded-lg p-6 border border-gray-700">
        <div className="flex justify-between items-center mb-4">
          <h2 className="text-xl font-bold">Open Positions</h2>
          <button
            onClick={fetchData}
            className="px-3 py-1 bg-blue-600 hover:bg-blue-700 text-sm rounded transition"
          >
            üîÑ Refresh
          </button>
        </div>

        {error && (
          <div className="bg-red-900/20 border border-red-700 text-red-300 px-4 py-2 rounded mb-4">
            {error}
          </div>
        )}

        {positions.length === 0 ? (
          <div className="text-center py-12">
            <div className="text-6xl mb-4">üìä</div>
            <div className="text-xl text-gray-400 mb-2">No open positions</div>
            <div className="text-sm text-gray-500">Place your first order from the Option Chain tab</div>
          </div>
        ) : (
          <div className="overflow-x-auto">
            <table className="w-full text-sm">
              <thead className="bg-gray-900">
                <tr>
                  <th className="p-3 text-left">Symbol</th>
                  <th className="p-3 text-right">Qty</th>
                  <th className="p-3 text-right">Avg Price</th>
                  <th className="p-3 text-right">Current Price</th>
                  <th className="p-3 text-right">P&L</th>
                  <th className="p-3 text-right">P&L %</th>
                  <th className="p-3 text-center">Action</th>
                </tr>
              </thead>
              <tbody>
                {positions.map((position, index) => {
                  const pnlPercent = ((position.currentPrice - position.avgPrice) / position.avgPrice) * 100;
                  
                  return (
                    <tr key={index} className="border-b border-gray-700 hover:bg-gray-700/50">
                      <td className="p-3 font-semibold">{position.symbol}</td>
                      <td className="p-3 text-right">{position.quantity}</td>
                      <td className="p-3 text-right">‚Çπ{position.avgPrice.toFixed(2)}</td>
                      <td className="p-3 text-right">‚Çπ{position.currentPrice.toFixed(2)}</td>
                      <td className={`p-3 text-right font-semibold ${
                        position.pnl >= 0 ? 'text-green-400' : 'text-red-400'
                      }`}>
                        {position.pnl >= 0 ? '+' : ''}‚Çπ{position.pnl.toFixed(2)}
                      </td>
                      <td className={`p-3 text-right font-semibold ${
                        pnlPercent >= 0 ? 'text-green-400' : 'text-red-400'
                      }`}>
                        {pnlPercent >= 0 ? '+' : ''}{pnlPercent.toFixed(2)}%
                      </td>
                      <td className="p-3 text-center">
                        <button
                          onClick={() => handleSquareOff(position)}
                          className="px-3 py-1 bg-red-600 hover:bg-red-700 text-white text-xs rounded transition"
                        >
                          Square Off
                        </button>
                      </td>
                    </tr>
                  );
                })}
              </tbody>
            </table>
          </div>
        )}
      </div>

      {/* Order History */}
      <OrderHistory />
    </div>
  );


  async function handleSquareOff(position: Position) {
    try {
      const apiUrl = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3001';
      
      const response = await fetch(`${apiUrl}/api/paper-trading/order`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          symbol: position.symbol,
          quantity: position.quantity,
          price: position.currentPrice,
          side: 'SELL',
          type: 'MARKET'
        })
      });

      if (!response.ok) {
        throw new Error('Failed to square off position');
      }

      alert(`‚úÖ Position squared off successfully!\nSymbol: ${position.symbol}\nP&L: ‚Çπ${position.pnl.toFixed(2)}`);
      
      // Refresh positions
      fetchData();
      
    } catch (error: any) {
      console.error('Square off error:', error);
      alert(`‚ùå Failed to square off: ${error.message}`);
    }
  }
}
</file>

<file path="frontend/components/Toast.tsx">
'use client';

import { useEffect } from 'react';

interface ToastProps {
  message: string;
  type: 'success' | 'error' | 'info';
  onClose: () => void;
  duration?: number;
}

export default function Toast({ message, type, onClose, duration = 3000 }: ToastProps) {
  useEffect(() => {
    const timer = setTimeout(onClose, duration);
    return () => clearTimeout(timer);
  }, [duration, onClose]);

  const bgColor = type === 'success' ? 'bg-green-600' : type === 'error' ? 'bg-red-600' : 'bg-blue-600';
  const icon = type === 'success' ? '‚úÖ' : type === 'error' ? '‚ùå' : '‚ÑπÔ∏è';

  return (
    <div className={`${bgColor} text-white px-6 py-4 rounded-lg shadow-lg flex items-center gap-3 min-w-[300px] animate-slide-in`}>
      <span className="text-2xl">{icon}</span>
      <div className="flex-1">
        <p className="font-medium">{message}</p>
      </div>
      <button onClick={onClose} className="text-white hover:text-gray-200 text-xl font-bold">
        √ó
      </button>
    </div>
  );
}
</file>

<file path="frontend/components/ToastContainer.tsx">
'use client';

import { createContext, useContext, useState, useCallback, ReactNode } from 'react';
import Toast from './Toast';

interface ToastMessage {
  id: number;
  message: string;
  type: 'success' | 'error' | 'info';
}

interface ToastContextType {
  showToast: (message: string, type: 'success' | 'error' | 'info') => void;
}

const ToastContext = createContext<ToastContextType | undefined>(undefined);

export function useToast() {
  const context = useContext(ToastContext);
  if (!context) {
    throw new Error('useToast must be used within ToastProvider');
  }
  return context;
}

export function ToastProvider({ children }: { children: ReactNode }) {
  const [toasts, setToasts] = useState<ToastMessage[]>([]);

  const showToast = useCallback((message: string, type: 'success' | 'error' | 'info') => {
    const id = Date.now();
    setToasts((prev) => [...prev, { id, message, type }]);
  }, []);

  const removeToast = useCallback((id: number) => {
    setToasts((prev) => prev.filter((toast) => toast.id !== id));
  }, []);

  return (
    <ToastContext.Provider value={{ showToast }}>
      {children}
      <div className="fixed bottom-4 right-4 z-50 flex flex-col gap-2">
        {toasts.map((toast) => (
          <Toast
            key={toast.id}
            message={toast.message}
            type={toast.type}
            onClose={() => removeToast(toast.id)}
          />
        ))}
      </div>
    </ToastContext.Provider>
  );
}
</file>

<file path="frontend/eslint.config.mjs">
import { defineConfig, globalIgnores } from "eslint/config";
import nextVitals from "eslint-config-next/core-web-vitals";
import nextTs from "eslint-config-next/typescript";

const eslintConfig = defineConfig([
  ...nextVitals,
  ...nextTs,
  // Override default ignores of eslint-config-next.
  globalIgnores([
    // Default ignores of eslint-config-next:
    ".next/**",
    "out/**",
    "build/**",
    "next-env.d.ts",
  ]),
]);

export default eslintConfig;
</file>

<file path="frontend/hooks/useWebSocket.ts">
'use client';

import { useEffect, useRef, useState } from 'react';

export function useWebSocket(url: string) {
  const [isConnected, setIsConnected] = useState(false);
  const [lastMessage, setLastMessage] = useState<any>(null);
  const ws = useRef<WebSocket | null>(null);
  const subscribers = useRef<Map<string, Set<(data: any) => void>>>(new Map());
  const reconnectTimeout = useRef<NodeJS.Timeout>();

  useEffect(() => {
    function connect() {
      try {
        ws.current = new WebSocket(url);

        ws.current.onopen = () => {
          console.log('‚úÖ WebSocket connected');
          setIsConnected(true);
        };

        ws.current.onmessage = (event) => {
          try {
            const data = JSON.parse(event.data);
            setLastMessage(data);
            
            if (data.channel) {
              const channelSubs = subscribers.current.get(data.channel);
              if (channelSubs) {
                channelSubs.forEach(callback => callback(data));
              }
            }
          } catch (error) {
            console.warn('Failed to parse WebSocket message:', error);
          }
        };

        ws.current.onclose = () => {
          console.log('WebSocket disconnected, will retry in 3s...');
          setIsConnected(false);
          
          // Auto-reconnect after 3 seconds
          reconnectTimeout.current = setTimeout(() => {
            connect();
          }, 3000);
        };

        ws.current.onerror = () => {
          console.warn('WebSocket connection error (will retry)');
        };
      } catch (error) {
        console.error('Failed to create WebSocket:', error);
      }
    }

    connect();

    return () => {
      if (reconnectTimeout.current) {
        clearTimeout(reconnectTimeout.current);
      }
      ws.current?.close();
    };
  }, [url]);

  const subscribe = (channels: string[], callback: (data: any) => void) => {
    channels.forEach(channel => {
      if (!subscribers.current.has(channel)) {
        subscribers.current.set(channel, new Set());
      }
      subscribers.current.get(channel)!.add(callback);
    });

    if (ws.current?.readyState === WebSocket.OPEN) {
      ws.current.send(JSON.stringify({ type: 'subscribe', channels }));
    }

    return () => {
      channels.forEach(channel => {
        subscribers.current.get(channel)?.delete(callback);
      });
    };
  };

  return { isConnected, lastMessage, subscribe };
}
</file>

<file path="frontend/lib/api.ts">
const API_BASE_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3001';

export const api = {
  // Market Data APIs
  getOptionChain: async (index: string, expiryDate: string) => {
    const response = await fetch(
      `${API_BASE_URL}/api/market-data/option-chain?instrument_key=${index}&expiry_date=${expiryDate}`
    );
    if (!response.ok) {
      throw new Error('Failed to fetch option chain');
    }
    return response.json();
  },

  getLTP: async (symbols: string[]) => {
    const symbolsParam = symbols.join(',');
    const response = await fetch(
      `${API_BASE_URL}/api/market-data/ltp?symbols=${symbolsParam}`
    );
    if (!response.ok) {
      throw new Error('Failed to fetch LTP');
    }
    return response.json();
  },

  getQuote: async (symbols: string[]) => {
    const symbolsParam = symbols.join(',');
    const response = await fetch(
      `${API_BASE_URL}/api/market-data/quote?symbols=${symbolsParam}`
    );
    if (!response.ok) {
      throw new Error('Failed to fetch quote');
    }
    return response.json();
  },

  // Paper Trading APIs
  getPortfolio: async () => {
    const response = await fetch(`${API_BASE_URL}/api/paper-trading/portfolio`);
    if (!response.ok) {
      throw new Error('Failed to fetch portfolio');
    }
    return response.json();
  },

  placeOrder: async (orderData: any) => {
    const response = await fetch(`${API_BASE_URL}/api/paper-trading/order`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(orderData),
    });
    if (!response.ok) {
      throw new Error('Failed to place order');
    }
    return response.json();
  },

  getOrders: async () => {
    const response = await fetch(`${API_BASE_URL}/api/paper-trading/orders`);
    if (!response.ok) {
      throw new Error('Failed to fetch orders');
    }
    return response.json();
  },
};
</file>

<file path="frontend/next.config.ts">
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
  reactCompiler: true,
};

export default nextConfig;
</file>

<file path="frontend/package.json">
{
  "name": "frontend",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --webpack",
    "build": "next build --webpack",
    "start": "next start",
    "lint": "eslint"
  },
  "dependencies": {
    "axios": "^1.13.2",
    "next": "16.0.1",
    "react": "19.2.0",
    "react-dom": "19.2.0"
  },
  "devDependencies": {
    "@tailwindcss/postcss": "^4",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "babel-plugin-react-compiler": "1.0.0",
    "eslint": "^9",
    "eslint-config-next": "16.0.1",
    "tailwindcss": "^4",
    "typescript": "^5"
  }
}
</file>

<file path="frontend/postcss.config.mjs">
const config = {
  plugins: {
    "@tailwindcss/postcss": {},
  },
};

export default config;
</file>

<file path="frontend/public/file.svg">
<svg fill="none" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M14.5 13.5V5.41a1 1 0 0 0-.3-.7L9.8.29A1 1 0 0 0 9.08 0H1.5v13.5A2.5 2.5 0 0 0 4 16h8a2.5 2.5 0 0 0 2.5-2.5m-1.5 0v-7H8v-5H3v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1M9.5 5V2.12L12.38 5zM5.13 5h-.62v1.25h2.12V5zm-.62 3h7.12v1.25H4.5zm.62 3h-.62v1.25h7.12V11z" clip-rule="evenodd" fill="#666" fill-rule="evenodd"/></svg>
</file>

<file path="frontend/public/globe.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g clip-path="url(#a)"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.27 14.1a6.5 6.5 0 0 0 3.67-3.45q-1.24.21-2.7.34-.31 1.83-.97 3.1M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16m.48-1.52a7 7 0 0 1-.96 0H7.5a4 4 0 0 1-.84-1.32q-.38-.89-.63-2.08a40 40 0 0 0 3.92 0q-.25 1.2-.63 2.08a4 4 0 0 1-.84 1.31zm2.94-4.76q1.66-.15 2.95-.43a7 7 0 0 0 0-2.58q-1.3-.27-2.95-.43a18 18 0 0 1 0 3.44m-1.27-3.54a17 17 0 0 1 0 3.64 39 39 0 0 1-4.3 0 17 17 0 0 1 0-3.64 39 39 0 0 1 4.3 0m1.1-1.17q1.45.13 2.69.34a6.5 6.5 0 0 0-3.67-3.44q.65 1.26.98 3.1M8.48 1.5l.01.02q.41.37.84 1.31.38.89.63 2.08a40 40 0 0 0-3.92 0q.25-1.2.63-2.08a4 4 0 0 1 .85-1.32 7 7 0 0 1 .96 0m-2.75.4a6.5 6.5 0 0 0-3.67 3.44 29 29 0 0 1 2.7-.34q.31-1.83.97-3.1M4.58 6.28q-1.66.16-2.95.43a7 7 0 0 0 0 2.58q1.3.27 2.95.43a18 18 0 0 1 0-3.44m.17 4.71q-1.45-.12-2.69-.34a6.5 6.5 0 0 0 3.67 3.44q-.65-1.27-.98-3.1" fill="#666"/></g><defs><clipPath id="a"><path fill="#fff" d="M0 0h16v16H0z"/></clipPath></defs></svg>
</file>

<file path="frontend/public/next.svg">
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>
</file>

<file path="frontend/public/vercel.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1155 1000"><path d="m577.3 0 577.4 1000H0z" fill="#fff"/></svg>
</file>

<file path="frontend/public/window.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 2.5h13v10a1 1 0 0 1-1 1h-11a1 1 0 0 1-1-1zM0 1h16v11.5a2.5 2.5 0 0 1-2.5 2.5h-11A2.5 2.5 0 0 1 0 12.5zm3.75 4.5a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5M7 4.75a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0m1.75.75a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5" fill="#666"/></svg>
</file>

<file path="frontend/README.md">
This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.
</file>

<file path="frontend/src/axios.ts">
import axios from 'axios';

const api = axios.create({
  baseURL: 'http://localhost:3000', // Make sure this matches your backend port
});

export default api;
</file>

<file path="frontend/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": [
      "dom",
      "dom.iterable",
      "esnext"
    ],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "react-jsx",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": [
        "./*"
      ]
    }
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts",
    ".next/dev/types/**/*.ts"
  ],
  "exclude": [
    "node_modules"
  ]
}
</file>

<file path="frontend/utils/marketStatus.ts">
export function isMarketOpen(): boolean {
  const now = new Date();
  
  // Get IST time (UTC+5:30)
  const istOffset = 5.5 * 60 * 60 * 1000;
  const istTime = new Date(now.getTime() + istOffset);
  
  const day = istTime.getUTCDay(); // 0 = Sunday, 6 = Saturday
  const hours = istTime.getUTCHours();
  const minutes = istTime.getUTCMinutes();
  
  // Weekend check
  if (day === 0 || day === 6) {
    return false;
  }
  
  // Market hours: 9:15 AM to 3:30 PM IST
  const marketStartTime = 9 * 60 + 15; // 9:15 AM in minutes
  const marketEndTime = 15 * 60 + 30;  // 3:30 PM in minutes
  const currentTimeInMinutes = hours * 60 + minutes;
  
  return currentTimeInMinutes >= marketStartTime && currentTimeInMinutes <= marketEndTime;
}

export function getMarketStatus(): {
  isOpen: boolean;
  message: string;
} {
  const now = new Date();
  const istOffset = 5.5 * 60 * 60 * 1000;
  const istTime = new Date(now.getTime() + istOffset);
  const day = istTime.getUTCDay();
  const hours = istTime.getUTCHours();
  const minutes = istTime.getUTCMinutes();
  
  // Weekend check
  if (day === 0 || day === 6) {
    return {
      isOpen: false,
      message: "Market is closed on weekends"
    };
  }
  
  const currentTimeInMinutes = hours * 60 + minutes;
  const marketStartTime = 9 * 60 + 15;
  const marketEndTime = 15 * 60 + 30;
  
  const open = currentTimeInMinutes >= marketStartTime && currentTimeInMinutes <= marketEndTime;
  
  if (!open) {
    if (currentTimeInMinutes < marketStartTime) {
      return {
        isOpen: false,
        message: "Market will open at 9:15 AM IST"
      };
    } else {
      return {
        isOpen: false,
        message: "Market closed at 3:30 PM IST"
      };
    }
  }
  
  return {
    isOpen: true,
    message: "Market is open"
  };
}
</file>

<file path="package.json">
{
  "name": "paper-trading-app",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "type": "commonjs",
  "dependencies": {
    "@prisma/client": "^6.19.0",
    "bcryptjs": "^3.0.3",
    "cors": "^2.8.5",
    "dotenv": "^17.2.3",
    "express": "^5.1.0",
    "ioredis": "^5.8.2",
    "jsonwebtoken": "^9.0.2",
    "ws": "^8.18.3",
    "zod": "^4.1.12"
  },
  "devDependencies": {
    "@types/bcryptjs": "^2.4.6",
    "@types/cors": "^2.8.19",
    "@types/express": "^5.0.5",
    "@types/jsonwebtoken": "^9.0.10",
    "@types/node": "^24.10.0",
    "@types/ws": "^8.18.1",
    "prisma": "^6.19.0",
    "tsx": "^4.20.6",
    "typescript": "^5.9.3"
  }
}
</file>

</files>
</file>

<file path="package.json">
{
  "name": "paper-trading-app",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "type": "commonjs",
  "dependencies": {
    "@prisma/client": "^6.19.0",
    "bcryptjs": "^3.0.3",
    "cors": "^2.8.5",
    "dotenv": "^17.2.3",
    "express": "^5.1.0",
    "ioredis": "^5.8.2",
    "jsonwebtoken": "^9.0.2",
    "ws": "^8.18.3",
    "zod": "^4.1.12"
  },
  "devDependencies": {
    "@types/bcryptjs": "^2.4.6",
    "@types/cors": "^2.8.19",
    "@types/express": "^5.0.5",
    "@types/jsonwebtoken": "^9.0.10",
    "@types/node": "^24.10.0",
    "@types/ws": "^8.18.1",
    "prisma": "^6.19.0",
    "tsx": "^4.20.6",
    "typescript": "^5.9.3"
  }
}
</file>

</files>
